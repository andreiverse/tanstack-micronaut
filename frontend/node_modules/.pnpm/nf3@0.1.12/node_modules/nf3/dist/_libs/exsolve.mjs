import fs,{lstatSync,realpathSync,statSync}from"node:fs";import{URL as URL$1,fileURLToPath,pathToFileURL}from"node:url";import path,{isAbsolute}from"node:path";import assert from"node:assert";import process$1 from"node:process";import v8 from"node:v8";import{format,inspect}from"node:util";const nodeBuiltins=`_http_agent._http_client._http_common._http_incoming._http_outgoing._http_server._stream_duplex._stream_passthrough._stream_readable._stream_transform._stream_wrap._stream_writable._tls_common._tls_wrap.assert.assert/strict.async_hooks.buffer.child_process.cluster.console.constants.crypto.dgram.diagnostics_channel.dns.dns/promises.domain.events.fs.fs/promises.http.http2.https.inspector.inspector/promises.module.net.os.path.path/posix.path/win32.perf_hooks.process.punycode.querystring.readline.readline/promises.repl.stream.stream/consumers.stream/promises.stream/web.string_decoder.sys.timers.timers/promises.tls.trace_events.tty.url.util.util/types.v8.vm.wasi.worker_threads.zlib`.split(`.`),own$1={}.hasOwnProperty,classRegExp=/^([A-Z][a-z\d]*)+$/,kTypes=new Set([`string`,`function`,`number`,`object`,`Function`,`Object`,`boolean`,`bigint`,`symbol`]),messages=new Map;let userStackTraceLimit;function formatList(l,R=`and`){return l.length<3?l.join(` ${R} `):`${l.slice(0,-1).join(`, `)}, ${R} ${l.at(-1)}`}function createError(l,R,z){return messages.set(l,R),makeNodeErrorWithCode(z,l)}function makeNodeErrorWithCode(l,R){return function(...z){let B=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);let V=new l;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=B);let H=getMessage(R,z,V);return Object.defineProperties(V,{message:{value:H,enumerable:!1,writable:!0,configurable:!0},toString:{value(){return`${this.name} [${R}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}}),captureLargerStackTrace(V),V.code=R,V}}function isErrorStackTraceLimitWritable(){try{if(v8.startupSnapshot.isBuildingSnapshot())return!1}catch{}let l=Object.getOwnPropertyDescriptor(Error,`stackTraceLimit`);return l===void 0?Object.isExtensible(Error):own$1.call(l,`writable`)&&l.writable!==void 0?l.writable:l.set!==void 0}function hideStackFrames(l){let R=`__node_internal_`+l.name;return Object.defineProperty(l,`name`,{value:R}),l}const captureLargerStackTrace=hideStackFrames(function(l){let R=isErrorStackTraceLimitWritable();return R&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=1/0),Error.captureStackTrace(l),R&&(Error.stackTraceLimit=userStackTraceLimit),l});function getMessage(l,R,z){let B=messages.get(l);if(assert.ok(B!==void 0,"expected `message` to be found"),typeof B==`function`)return assert.ok(B.length<=R.length,`Code: ${l}; The provided arguments length (${R.length}) does not match the required ones (${B.length}).`),Reflect.apply(B,z,R);let V=/%[dfijoOs]/g,H=0;for(;V.exec(B)!==null;)H++;return assert.ok(H===R.length,`Code: ${l}; The provided arguments length (${R.length}) does not match the required ones (${H}).`),R.length===0?B:(R.unshift(B),Reflect.apply(format,null,R))}function determineSpecificType(l){if(l==null)return String(l);if(typeof l==`function`&&l.name)return`function ${l.name}`;if(typeof l==`object`)return l.constructor&&l.constructor.name?`an instance of ${l.constructor.name}`:`${inspect(l,{depth:-1})}`;let R=inspect(l,{colors:!1});return R.length>28&&(R=`${R.slice(0,25)}...`),`type ${typeof l} (${R})`}createError(`ERR_INVALID_ARG_TYPE`,(l,R,z)=>{assert.ok(typeof l==`string`,`'name' must be a string`),Array.isArray(R)||(R=[R]);let B=`The `;if(l.endsWith(` argument`))B+=`${l} `;else{let R=l.includes(`.`)?`property`:`argument`;B+=`"${l}" ${R} `}B+=`must be `;let V=[],H=[],U=[];for(let l of R)assert.ok(typeof l==`string`,`All expected entries have to be of type string`),kTypes.has(l)?V.push(l.toLowerCase()):classRegExp.exec(l)===null?(assert.ok(l!==`object`,`The value "object" should be written as "Object"`),U.push(l)):H.push(l);if(H.length>0){let l=V.indexOf(`object`);l!==-1&&(V.slice(l,1),H.push(`Object`))}return V.length>0&&(B+=`${V.length>1?`one of type`:`of type`} ${formatList(V,`or`)}`,(H.length>0||U.length>0)&&(B+=` or `)),H.length>0&&(B+=`an instance of ${formatList(H,`or`)}`,U.length>0&&(B+=` or `)),U.length>0&&(U.length>1?B+=`one of ${formatList(U,`or`)}`:(U[0]?.toLowerCase()!==U[0]&&(B+=`an `),B+=`${U[0]}`)),B+=`. Received ${determineSpecificType(z)}`,B},TypeError);const ERR_INVALID_MODULE_SPECIFIER=createError(`ERR_INVALID_MODULE_SPECIFIER`,(l,R,z)=>`Invalid module "${l}" ${R}${z?` imported from ${z}`:``}`,TypeError),ERR_INVALID_PACKAGE_CONFIG=createError(`ERR_INVALID_PACKAGE_CONFIG`,(l,R,z)=>`Invalid package config ${l}${R?` while importing ${R}`:``}${z?`. ${z}`:``}`,Error),ERR_INVALID_PACKAGE_TARGET=createError(`ERR_INVALID_PACKAGE_TARGET`,(l,R,z,B=!1,V)=>{let H=typeof z==`string`&&!B&&z.length>0&&!z.startsWith(`./`);return R===`.`?(assert.ok(B===!1),`Invalid "exports" main target ${JSON.stringify(z)} defined in the package config ${l}package.json${V?` imported from ${V}`:``}${H?`; targets must start with "./"`:``}`):`Invalid "${B?`imports`:`exports`}" target ${JSON.stringify(z)} defined for '${R}' in the package config ${l}package.json${V?` imported from ${V}`:``}${H?`; targets must start with "./"`:``}`},Error),ERR_MODULE_NOT_FOUND=createError(`ERR_MODULE_NOT_FOUND`,(l,R,z=!1)=>`Cannot find ${z?`module`:`package`} '${l}' imported from ${R}`,Error);createError(`ERR_NETWORK_IMPORT_DISALLOWED`,`import of '%s' by %s is not supported: %s`,Error);const ERR_PACKAGE_IMPORT_NOT_DEFINED=createError(`ERR_PACKAGE_IMPORT_NOT_DEFINED`,(l,R,z)=>`Package import specifier "${l}" is not defined${R?` in package ${R||``}package.json`:``} imported from ${z}`,TypeError),ERR_PACKAGE_PATH_NOT_EXPORTED=createError(`ERR_PACKAGE_PATH_NOT_EXPORTED`,(l,R,z)=>R===`.`?`No "exports" main defined in ${l}package.json${z?` imported from ${z}`:``}`:`Package subpath '${R}' is not defined by "exports" in ${l}package.json${z?` imported from ${z}`:``}`,Error),ERR_UNSUPPORTED_DIR_IMPORT=createError(`ERR_UNSUPPORTED_DIR_IMPORT`,`Directory import '%s' is not supported resolving ES modules imported from %s`,Error),ERR_UNSUPPORTED_RESOLVE_REQUEST=createError(`ERR_UNSUPPORTED_RESOLVE_REQUEST`,`Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.`,TypeError),ERR_UNKNOWN_FILE_EXTENSION=createError(`ERR_UNKNOWN_FILE_EXTENSION`,(l,R)=>`Unknown file extension "${l}" for ${R}`,TypeError);createError(`ERR_INVALID_ARG_VALUE`,(l,R,z=`is invalid`)=>{let B=inspect(R);return B.length>128&&(B=`${B.slice(0,128)}...`),`The ${l.includes(`.`)?`property`:`argument`} '${l}' ${z}. Received ${B}`},TypeError);const hasOwnProperty$1={}.hasOwnProperty,cache=new Map;function read(R,{base:z,specifier:B}){let V=cache.get(R);if(V)return V;let U;try{U=fs.readFileSync(path.toNamespacedPath(R),`utf8`)}catch(l){let R=l;if(R.code!==`ENOENT`)throw R}let G={exists:!1,pjsonPath:R,main:void 0,name:void 0,type:`none`,exports:void 0,imports:void 0};if(U!==void 0){let l;try{l=JSON.parse(U)}catch(l){let V=new ERR_INVALID_PACKAGE_CONFIG(R,(z?`"${B}" from `:``)+fileURLToPath(z||B),l.message);throw V.cause=l,V}G.exists=!0,hasOwnProperty$1.call(l,`name`)&&typeof l.name==`string`&&(G.name=l.name),hasOwnProperty$1.call(l,`main`)&&typeof l.main==`string`&&(G.main=l.main),hasOwnProperty$1.call(l,`exports`)&&(G.exports=l.exports),hasOwnProperty$1.call(l,`imports`)&&(G.imports=l.imports),hasOwnProperty$1.call(l,`type`)&&(l.type===`commonjs`||l.type===`module`)&&(G.type=l.type)}return cache.set(R,G),G}function getPackageScopeConfig(l){let R=new URL(`package.json`,l);for(;!R.pathname.endsWith(`node_modules/package.json`);){let z=read(fileURLToPath(R),{specifier:l});if(z.exists)return z;let B=R;if(R=new URL(`../package.json`,R),R.pathname===B.pathname)break}return{pjsonPath:fileURLToPath(R),exists:!1,type:`none`}}const hasOwnProperty={}.hasOwnProperty,extensionFormatMap={__proto__:null,".json":`json`,".cjs":`commonjs`,".cts":`commonjs`,".js":`module`,".ts":`module`,".mts":`module`,".mjs":`module`},protocolHandlers={__proto__:null,"data:":getDataProtocolModuleFormat,"file:":getFileProtocolModuleFormat,"node:":()=>`builtin`};function mimeToFormat(l){return l&&/\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(l)?`module`:l===`application/json`?`json`:null}function getDataProtocolModuleFormat(l){let{1:R}=/^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(l.pathname)||[null,null,null];return mimeToFormat(R)}function extname$1(l){let R=l.pathname,z=R.length;for(;z--;){let l=R.codePointAt(z);if(l===47)return``;if(l===46)return R.codePointAt(z-1)===47?``:R.slice(z)}return``}function getFileProtocolModuleFormat(l,R,z){let B=extname$1(l);if(B===`.js`){let{type:R}=getPackageScopeConfig(l);return R===`none`?`commonjs`:R}if(B===``){let{type:R}=getPackageScopeConfig(l);return R===`none`||R===`commonjs`?`commonjs`:`module`}let V=extensionFormatMap[B];if(V)return V;if(!z)throw new ERR_UNKNOWN_FILE_EXTENSION(B,fileURLToPath(l))}function defaultGetFormatWithoutErrors(l,R){let z=l.protocol;return hasOwnProperty.call(protocolHandlers,z)&&protocolHandlers[z](l,R,!0)||null}const RegExpPrototypeSymbolReplace=RegExp.prototype[Symbol.replace],own={}.hasOwnProperty,invalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,deprecatedInvalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,invalidPackageNameRegEx=/^\.|%|\\/,patternRegEx=/\*/g,encodedSeparatorRegEx=/%2f|%5c/i,emittedPackageWarnings=new Set,doubleSlashRegEx=/[/\\]{2}/;function emitInvalidSegmentDeprecation(l,R,z,B,V,U,W){if(process$1.noDeprecation)return;let G=fileURLToPath(B),K=doubleSlashRegEx.exec(W?l:R)!==null;process$1.emitWarning(`Use of deprecated ${K?`double slash`:`leading or trailing slash matching`} resolving "${l}" for module request "${R}" ${R===z?``:`matched to "${z}" `}in the "${V?`imports`:`exports`}" field module resolution of the package at ${G}${U?` imported from ${fileURLToPath(U)}`:``}.`,`DeprecationWarning`,`DEP0166`)}function emitLegacyIndexDeprecation(l,R,z,B){if(process$1.noDeprecation||defaultGetFormatWithoutErrors(l,{parentURL:z.href})!==`module`)return;let U=fileURLToPath(l.href),G=fileURLToPath(new URL$1(`.`,R)),K=fileURLToPath(z);B?path.resolve(G,B)!==U&&process$1.emitWarning(`Package ${G} has a "main" field set to "${B}", excluding the full filename and extension to the resolved file at "${U.slice(G.length)}", imported from ${K}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`,`DeprecationWarning`,`DEP0151`):process$1.emitWarning(`No "main" or "exports" field defined in the package.json for ${G} resolving the main entry point "${U.slice(G.length)}", imported from ${K}.\nDefault "index" lookups for the main are deprecated for ES modules.`,`DeprecationWarning`,`DEP0151`)}function tryStatSync(l){try{return statSync(l)}catch{}}function fileExists(l){let R=statSync(l,{throwIfNoEntry:!1});return(R?R.isFile():void 0)??!1}function legacyMainResolve(l,R,z){let B;if(R.main!==void 0){if(B=new URL$1(R.main,l),fileExists(B))return B;let H=[`./${R.main}.js`,`./${R.main}.json`,`./${R.main}.node`,`./${R.main}/index.js`,`./${R.main}/index.json`,`./${R.main}/index.node`],U=-1;for(;++U<H.length&&(B=new URL$1(H[U],l),!fileExists(B));)B=void 0;if(B)return emitLegacyIndexDeprecation(B,l,z,R.main),B}let U=[`./index.js`,`./index.json`,`./index.node`],W=-1;for(;++W<U.length&&(B=new URL$1(U[W],l),!fileExists(B));)B=void 0;if(B)return emitLegacyIndexDeprecation(B,l,z,R.main),B;throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL$1(`.`,l)),fileURLToPath(z))}function finalizeResolution(l,R,B){if(encodedSeparatorRegEx.exec(l.pathname)!==null)throw new ERR_INVALID_MODULE_SPECIFIER(l.pathname,String.raw`must not include encoded "/" or "\" characters`,fileURLToPath(R));let V;try{V=fileURLToPath(l)}catch(z){throw Object.defineProperty(z,`input`,{value:String(l)}),Object.defineProperty(z,`module`,{value:String(R)}),z}let G=tryStatSync(V.endsWith(`/`)?V.slice(-1):V);if(G&&G.isDirectory()){let z=new ERR_UNSUPPORTED_DIR_IMPORT(V,fileURLToPath(R));throw z.url=String(l),z}if(!G||!G.isFile()){let z=new ERR_MODULE_NOT_FOUND(V||l.pathname,R&&fileURLToPath(R),!0);throw z.url=String(l),z}if(!B){let R=realpathSync(V),{search:B,hash:H}=l;l=pathToFileURL(R+(V.endsWith(path.sep)?`/`:``)),l.search=B,l.hash=H}return l}function importNotDefined(l,R,z){return new ERR_PACKAGE_IMPORT_NOT_DEFINED(l,R&&fileURLToPath(new URL$1(`.`,R)),fileURLToPath(z))}function exportsNotFound(l,R,z){return new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL$1(`.`,R)),l,z&&fileURLToPath(z))}function throwInvalidSubpath(l,R,z,B,V){throw new ERR_INVALID_MODULE_SPECIFIER(l,`request is not a valid match in pattern "${R}" for the "${B?`imports`:`exports`}" resolution of ${fileURLToPath(z)}`,V&&fileURLToPath(V))}function invalidPackageTarget(l,R,z,B,U){return R=typeof R==`object`&&R?JSON.stringify(R,null,``):`${R}`,new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL$1(`.`,z)),l,R,B,U&&fileURLToPath(U))}function resolvePackageTargetString(l,R,z,B,H,U,W,G,K){if(R!==``&&!U&&l.at(-1)!==`/`)throw invalidPackageTarget(z,l,B,W,H);if(!l.startsWith(`./`)){if(W&&!l.startsWith(`../`)&&!l.startsWith(`/`)){let z=!1;try{new URL$1(l),z=!0}catch{}if(!z)return packageResolve(U?RegExpPrototypeSymbolReplace.call(patternRegEx,l,()=>R):l+R,B,K)}throw invalidPackageTarget(z,l,B,W,H)}if(invalidSegmentRegEx.exec(l.slice(2))!==null)if(deprecatedInvalidSegmentRegEx.exec(l.slice(2))===null){if(!G){let V=U?z.replace(`*`,()=>R):z+R;emitInvalidSegmentDeprecation(U?RegExpPrototypeSymbolReplace.call(patternRegEx,l,()=>R):l,V,z,B,W,H,!0)}}else throw invalidPackageTarget(z,l,B,W,H);let q=new URL$1(l,B),J=q.pathname,Y=new URL$1(`.`,B).pathname;if(!J.startsWith(Y))throw invalidPackageTarget(z,l,B,W,H);if(R===``)return q;if(invalidSegmentRegEx.exec(R)!==null){let V=U?z.replace(`*`,()=>R):z+R;deprecatedInvalidSegmentRegEx.exec(R)===null?G||emitInvalidSegmentDeprecation(U?RegExpPrototypeSymbolReplace.call(patternRegEx,l,()=>R):l,V,z,B,W,H,!1):throwInvalidSubpath(V,z,B,W,H)}return U?new URL$1(RegExpPrototypeSymbolReplace.call(patternRegEx,q.href,()=>R)):new URL$1(R,q)}function isArrayIndex(l){let R=Number(l);return`${R}`===l?R>=0&&R<4294967295:!1}function resolvePackageTarget(l,R,z,B,V,U,W,G,K){if(typeof R==`string`)return resolvePackageTargetString(R,z,B,l,V,U,W,G,K);if(Array.isArray(R)){let H=R;if(H.length===0)return null;let q,J=-1;for(;++J<H.length;){let R=H[J],Y;try{Y=resolvePackageTarget(l,R,z,B,V,U,W,G,K)}catch(l){let R=l;if(q=R,R.code===`ERR_INVALID_PACKAGE_TARGET`)continue;throw l}if(Y!==void 0){if(Y===null){q=null;continue}return Y}}if(q==null)return null;throw q}if(typeof R==`object`&&R){let q=Object.getOwnPropertyNames(R),J=-1;for(;++J<q.length;){let R=q[J];if(isArrayIndex(R))throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(l),fileURLToPath(V),`"exports" cannot contain numeric property keys.`)}for(J=-1;++J<q.length;){let H=q[J];if(H===`default`||K&&K.has(H)){let q=R[H],J=resolvePackageTarget(l,q,z,B,V,U,W,G,K);if(J===void 0)continue;return J}}return null}if(R===null)return null;throw invalidPackageTarget(B,R,l,W,V)}function isConditionalExportsMainSugar(l,R,z){if(typeof l==`string`||Array.isArray(l))return!0;if(typeof l!=`object`||!l)return!1;let B=Object.getOwnPropertyNames(l),V=!1,U=0,W=-1;for(;++W<B.length;){let l=B[W],G=l===``||l[0]!==`.`;if(U++===0)V=G;else if(V!==G)throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(R),fileURLToPath(z),`"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`)}return V}function emitTrailingSlashPatternDeprecation(l,R,z){if(process$1.noDeprecation)return;let B=fileURLToPath(R);emittedPackageWarnings.has(B+`|`+l)||(emittedPackageWarnings.add(B+`|`+l),process$1.emitWarning(`Use of deprecated trailing slash pattern mapping "${l}" in the "exports" field module resolution of the package at ${B}${z?` imported from ${fileURLToPath(z)}`:``}. Mapping specifiers ending in "/" is no longer supported.`,`DeprecationWarning`,`DEP0155`))}function packageExportsResolve(l,R,z,B,V){let H=z.exports;if(isConditionalExportsMainSugar(H,l,B)&&(H={".":H}),own.call(H,R)&&!R.includes(`*`)&&!R.endsWith(`/`)){let z=H[R],U=resolvePackageTarget(l,z,``,R,B,!1,!1,!1,V);if(U==null)throw exportsNotFound(R,l,B);return U}let U=``,W=``,G=Object.getOwnPropertyNames(H),K=-1;for(;++K<G.length;){let z=G[K],V=z.indexOf(`*`);if(V!==-1&&R.startsWith(z.slice(0,V))){R.endsWith(`/`)&&emitTrailingSlashPatternDeprecation(R,l,B);let H=z.slice(V+1);R.length>=z.length&&R.endsWith(H)&&patternKeyCompare(U,z)===1&&z.lastIndexOf(`*`)===V&&(U=z,W=R.slice(V,R.length-H.length))}}if(U){let z=H[U],G=resolvePackageTarget(l,z,W,U,B,!0,!1,R.endsWith(`/`),V);if(G==null)throw exportsNotFound(R,l,B);return G}throw exportsNotFound(R,l,B)}function patternKeyCompare(l,R){let z=l.indexOf(`*`),B=R.indexOf(`*`),V=z===-1?l.length:z+1,H=B===-1?R.length:B+1;return V>H?-1:H>V||z===-1?1:B===-1||l.length>R.length?-1:R.length>l.length?1:0}function packageImportsResolve(l,R,z){if(l===`#`||l.startsWith(`#/`)||l.endsWith(`/`))throw new ERR_INVALID_MODULE_SPECIFIER(l,`is not a valid internal imports specifier name`,fileURLToPath(R));let B,V=getPackageScopeConfig(R);if(V.exists){B=pathToFileURL(V.pjsonPath);let H=V.imports;if(H)if(own.call(H,l)&&!l.includes(`*`)){let V=resolvePackageTarget(B,H[l],``,l,R,!1,!0,!1,z);if(V!=null)return V}else{let V=``,U=``,W=Object.getOwnPropertyNames(H),G=-1;for(;++G<W.length;){let R=W[G],z=R.indexOf(`*`);if(z!==-1&&l.startsWith(R.slice(0,-1))){let B=R.slice(z+1);l.length>=R.length&&l.endsWith(B)&&patternKeyCompare(V,R)===1&&R.lastIndexOf(`*`)===z&&(V=R,U=l.slice(z,l.length-B.length))}}if(V){let l=H[V],W=resolvePackageTarget(B,l,U,V,R,!0,!0,!1,z);if(W!=null)return W}}}throw importNotDefined(l,B,R)}function parsePackageName(l,R){let z=l.indexOf(`/`),B=!0,V=!1;l[0]===`@`&&(V=!0,z===-1||l.length===0?B=!1:z=l.indexOf(`/`,z+1));let U=z===-1?l:l.slice(0,z);if(invalidPackageNameRegEx.exec(U)!==null&&(B=!1),!B)throw new ERR_INVALID_MODULE_SPECIFIER(l,`is not a valid package name`,fileURLToPath(R));return{packageName:U,packageSubpath:`.`+(z===-1?``:l.slice(z)),isScoped:V}}function packageResolve(l,R,z){if(nodeBuiltins.includes(l))return new URL$1(`node:`+l);let{packageName:B,packageSubpath:W,isScoped:G}=parsePackageName(l,R),K=getPackageScopeConfig(R);if(K.exists&&K.name===B&&K.exports!==void 0&&K.exports!==null)return packageExportsResolve(pathToFileURL(K.pjsonPath),W,K,R,z);let q=new URL$1(`./node_modules/`+B+`/package.json`,R),J=fileURLToPath(q),Y;do{let U=tryStatSync(J.slice(0,-13));if(!U||!U.isDirectory()){Y=J,q=new URL$1((G?`../../../../node_modules/`:`../../../node_modules/`)+B+`/package.json`,q),J=fileURLToPath(q);continue}let K=read(J,{base:R,specifier:l});return K.exports!==void 0&&K.exports!==null?packageExportsResolve(q,W,K,R,z):W===`.`?legacyMainResolve(q,K,R):new URL$1(W,q)}while(J.length!==Y.length);throw new ERR_MODULE_NOT_FOUND(B,fileURLToPath(R),!1)}function isRelativeSpecifier(l){return l[0]===`.`&&(l.length===1||l[1]===`/`||l[1]===`.`&&(l.length===2||l[2]===`/`))}function shouldBeTreatedAsRelativeOrAbsolutePath(l){return l===``?!1:l[0]===`/`?!0:isRelativeSpecifier(l)}function moduleResolve(l,R,z,B){let H=R.protocol,U=H===`data:`,W;if(shouldBeTreatedAsRelativeOrAbsolutePath(l))try{W=new URL$1(l,R)}catch(z){let B=new ERR_UNSUPPORTED_RESOLVE_REQUEST(l,R);throw B.cause=z,B}else if(H===`file:`&&l[0]===`#`)W=packageImportsResolve(l,R,z);else try{W=new URL$1(l)}catch(B){if(U&&!nodeBuiltins.includes(l)){let z=new ERR_UNSUPPORTED_RESOLVE_REQUEST(l,R);throw z.cause=B,z}W=packageResolve(l,R,z)}return assert.ok(W!==void 0,`expected to be defined`),W.protocol===`file:`?finalizeResolution(W,R,B):W}const DEFAULT_CONDITIONS_SET=new Set([`node`,`import`]),isWindows=(()=>process.platform===`win32`)(),globalCache=(()=>globalThis.__EXSOLVE_CACHE__||=new Map)();function resolveModuleURL(l,B){let V=_parseInput(l);if(`external`in V)return V.external;let H=V.specifier,W=V.url,G=V.absolutePath,K,q;if(B?.cache!==!1&&(K=_cacheKey(G||H,B),q=B?.cache&&typeof B?.cache==`object`?B.cache:globalCache),q){let l=q.get(K);if(typeof l==`string`)return l;if(l instanceof Error){if(B?.try)return;throw l}}if(G)try{let l=lstatSync(G);if(l.isSymbolicLink()&&(G=realpathSync(G),W=pathToFileURL(G)),l.isFile())return q&&q.set(K,W.href),W.href}catch(l){if(l?.code!==`ENOENT`)throw q&&q.set(K,l),l}let J=B?.conditions?new Set(B.conditions):DEFAULT_CONDITIONS_SET,Y=H||W.href,X=_normalizeBases(B?.from),Z=B?.suffixes||[``],Q=B?.extensions?[``,...B.extensions]:[``],$;for(let l of X){for(let R of Z){let z=_join(Y,R);z===`.`&&(z+=`/.`);for(let R of Q)if($=_tryModuleResolve(z+R,l,J),$)break;if($)break}if($)break}if(!$){let R=Error(`Cannot resolve module "${l}" (from: ${X.map(l=>_fmtPath(l)).join(`, `)})`);if(R.code=`ERR_MODULE_NOT_FOUND`,q&&q.set(K,R),B?.try)return;throw R}return q&&q.set(K,$.href),$.href}function resolveModulePath(l,R){let z=resolveModuleURL(l,R);if(!z||!z.startsWith(`file://`)&&R?.try)return;let B=fileURLToPath(z);return isWindows?_normalizeWinPath(B):B}function _tryModuleResolve(l,R,z){try{return moduleResolve(l,R,z)}catch{}}function _normalizeBases(l){let R=(Array.isArray(l)?l:[l]).flatMap(l=>_normalizeBase(l));return R.length===0?[pathToFileURL(`./`)]:R}function _normalizeBase(l){if(!l)return[];if(_isURL(l))return[l];if(typeof l!=`string`)return[];if(/^(?:node|data|http|https|file):/.test(l))return new URL(l);try{return l.endsWith(`/`)||statSync(l).isDirectory()?pathToFileURL(l+`/`):pathToFileURL(l)}catch{return[pathToFileURL(l+`/`),pathToFileURL(l)]}}function _fmtPath(l){try{return fileURLToPath(l)}catch{return l}}function _cacheKey(l,R){return JSON.stringify([l,(R?.conditions||[`node`,`import`]).sort(),R?.extensions,R?.from,R?.suffixes])}function _join(l,R){return!l||!R||R===`/`?l:(l.endsWith(`/`)?l:l+`/`)+(R.startsWith(`/`)?R.slice(1):R)}function _normalizeWinPath(l){return l.replace(/\\/g,`/`).replace(/^[a-z]:\//,l=>l.toUpperCase())}function _isURL(l){return l instanceof URL||l?.constructor?.name===`URL`}function _parseInput(l){if(typeof l==`string`){if(l.startsWith(`file:`)){let R=new URL(l);return{url:R,absolutePath:fileURLToPath(R)}}return isAbsolute(l)?{url:pathToFileURL(l),absolutePath:l}:/^(?:node|data|http|https):/.test(l)?{external:l}:nodeBuiltins.includes(l)&&!l.includes(`:`)?{external:`node:${l}`}:{specifier:l}}if(_isURL(l))return l.protocol===`file:`?{url:l,absolutePath:fileURLToPath(l)}:{external:l.href};throw TypeError("id must be a `string` or `URL`")}export{resolveModuleURL as n,resolveModulePath as t};