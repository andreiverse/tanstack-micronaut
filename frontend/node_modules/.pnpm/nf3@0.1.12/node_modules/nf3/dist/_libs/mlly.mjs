import{a as x,i as h}from"./confbox.mjs";import fs,{promises,realpathSync,statSync}from"node:fs";import{URL as URL$1,fileURLToPath,pathToFileURL}from"node:url";import path from"node:path";import assert from"node:assert";import process$1 from"node:process";import v8 from"node:v8";import{format,inspect}from"node:util";import"acorn";import{builtinModules}from"node:module";const _DRIVE_LETTER_START_RE=/^[A-Za-z]:\//;function normalizeWindowsPath(p=``){return p&&p.replace(/\\/g,`/`).replace(_DRIVE_LETTER_START_RE,p=>p.toUpperCase())}const _UNC_REGEX=/^[/\\]{2}/,_IS_ABSOLUTE_RE=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/,_DRIVE_LETTER_RE=/^[A-Za-z]:$/,_ROOT_FOLDER_RE=/^\/([A-Za-z]:)?$/,_EXTNAME_RE=/.(\.[^./]+|\.)$/,normalize=function(p){if(p.length===0)return`.`;p=normalizeWindowsPath(p);let H=p.match(_UNC_REGEX),U=isAbsolute$1(p),W=p[p.length-1]===`/`;return p=normalizeString(p,!U),p.length===0?U?`/`:W?`./`:`.`:(W&&(p+=`/`),_DRIVE_LETTER_RE.test(p)&&(p+=`/`),H?U?`//${p}`:`//./${p}`:U&&!isAbsolute$1(p)?`/${p}`:p)},join=function(...p){let H=``;for(let U of p)if(U)if(H.length>0){let p=H[H.length-1]===`/`,W=U[0]===`/`;p&&W?H+=U.slice(1):H+=p||W?U:`/${U}`}else H+=U;return normalize(H)};function cwd(){return typeof process<`u`&&typeof process.cwd==`function`?process.cwd().replace(/\\/g,`/`):`/`}const resolve=function(...p){p=p.map(p=>normalizeWindowsPath(p));let H=``,U=!1;for(let W=p.length-1;W>=-1&&!U;W--){let G=W>=0?p[W]:cwd();!G||G.length===0||(H=`${G}/${H}`,U=isAbsolute$1(G))}return H=normalizeString(H,!U),U&&!isAbsolute$1(H)?`/${H}`:H.length>0?H:`.`};function normalizeString(p,H){let U=``,W=0,G=-1,K=0,q=null;for(let J=0;J<=p.length;++J){if(J<p.length)q=p[J];else if(q===`/`)break;else q=`/`;if(q===`/`){if(!(G===J-1||K===1))if(K===2){if(U.length<2||W!==2||U[U.length-1]!==`.`||U[U.length-2]!==`.`){if(U.length>2){let p=U.lastIndexOf(`/`);p===-1?(U=``,W=0):(U=U.slice(0,p),W=U.length-1-U.lastIndexOf(`/`)),G=J,K=0;continue}else if(U.length>0){U=``,W=0,G=J,K=0;continue}}H&&(U+=U.length>0?`/..`:`..`,W=2)}else U.length>0?U+=`/${p.slice(G+1,J)}`:U=p.slice(G+1,J),W=J-G-1;G=J,K=0}else q===`.`&&K!==-1?++K:K=-1}return U}const isAbsolute$1=function(p){return _IS_ABSOLUTE_RE.test(p)},extname$1=function(p){if(p===`..`)return``;let H=_EXTNAME_RE.exec(normalizeWindowsPath(p));return H&&H[1]||``},relative=function(p,H){let U=resolve(p).replace(_ROOT_FOLDER_RE,`$1`).split(`/`),W=resolve(H).replace(_ROOT_FOLDER_RE,`$1`).split(`/`);if(W[0][1]===`:`&&U[0][1]===`:`&&U[0]!==W[0])return W.join(`/`);let G=[...U];for(let p of G){if(W[0]!==p)break;U.shift(),W.shift()}return[...U.map(()=>`..`),...W].join(`/`)},dirname$1=function(p){let H=normalizeWindowsPath(p).replace(/\/$/,``).split(`/`).slice(0,-1);return H.length===1&&_DRIVE_LETTER_RE.test(H[0])&&(H[0]+=`/`),H.join(`/`)||(isAbsolute$1(p)?`/`:`.`)},basename=function(p,H){let U=normalizeWindowsPath(p).split(`/`),W=``;for(let p=U.length-1;p>=0;p--){let H=U[p];if(H){W=H;break}}return H&&W.endsWith(H)?W.slice(0,-H.length):W};String.fromCharCode;const TRAILING_SLASH_RE=/\/$|\/\?|\/#/,JOIN_LEADING_SLASH_RE=/^\.?\//;function hasTrailingSlash(p=``,H){return H?TRAILING_SLASH_RE.test(p):p.endsWith(`/`)}function withTrailingSlash(p=``,H){if(!H)return p.endsWith(`/`)?p:p+`/`;if(hasTrailingSlash(p,!0))return p||`/`;let U=p,W=``,G=p.indexOf(`#`);if(G!==-1&&(U=p.slice(0,G),W=p.slice(G),!U))return W;let[K,...q]=U.split(`?`);return K+`/`+(q.length>0?`?${q.join(`?`)}`:``)+W}function isNonEmptyURL(p){return p&&p!==`/`}function joinURL(p,...H){let U=p||``;for(let p of H.filter(p=>isNonEmptyURL(p)))if(U){let H=p.replace(JOIN_LEADING_SLASH_RE,``);U=withTrailingSlash(U)+H}else U=p;return U}const defaultFindOptions={startingFrom:`.`,rootPattern:/^node_modules$/,reverse:!1,test:p=>{try{if(statSync(p).isFile())return!0}catch{}}};async function findFile(p,H={}){let U=Array.isArray(p)?p:[p],W={...defaultFindOptions,...H},G=resolve(W.startingFrom),K=G[0]===`/`,q=G.split(`/`).filter(Boolean);K&&(q[0]=`/`+q[0]);let J=q.findIndex(p=>p.match(W.rootPattern));if(J===-1&&(J=0),W.reverse)for(let p=J+1;p<=q.length;p++)for(let H of U){let U=join(...q.slice(0,p),H);if(await W.test(U))return U}else for(let p=q.length;p>J;p--)for(let H of U){let U=join(...q.slice(0,p),H);if(await W.test(U))return U}throw Error(`Cannot find matching ${p} in ${W.startingFrom} or parent directories`)}function findNearestFile(p,H={}){return findFile(p,H)}const FileCache=new Map;async function readPackageJSON(U,G={}){let K=await resolvePackageJSON(U,G),q=G.cache&&typeof G.cache!=`boolean`?G.cache:FileCache;if(G.cache&&q.has(K))return q.get(K);let J=await promises.readFile(K,`utf8`),Y;try{Y=x(J)}catch{Y=h(J)}return q.set(K,Y),Y}async function resolvePackageJSON(p=process.cwd(),H={}){return findNearestFile(`package.json`,{startingFrom:isAbsolute$1(p)?p:await resolvePath(p,H),...H})}const BUILTIN_MODULES=new Set(builtinModules);function normalizeSlash(p){return p.replace(/\\/g,`/`)}const own$1={}.hasOwnProperty,classRegExp=/^([A-Z][a-z\d]*)+$/,kTypes=new Set([`string`,`function`,`number`,`object`,`Function`,`Object`,`boolean`,`bigint`,`symbol`]),codes={};function formatList(p,H=`and`){return p.length<3?p.join(` ${H} `):`${p.slice(0,-1).join(`, `)}, ${H} ${p[p.length-1]}`}const messages=new Map;let userStackTraceLimit;codes.ERR_INVALID_ARG_TYPE=createError(`ERR_INVALID_ARG_TYPE`,(p,H,U)=>{assert(typeof p==`string`,`'name' must be a string`),Array.isArray(H)||(H=[H]);let W=`The `;if(p.endsWith(` argument`))W+=`${p} `;else{let H=p.includes(`.`)?`property`:`argument`;W+=`"${p}" ${H} `}W+=`must be `;let G=[],K=[],q=[];for(let p of H)assert(typeof p==`string`,`All expected entries have to be of type string`),kTypes.has(p)?G.push(p.toLowerCase()):classRegExp.exec(p)===null?(assert(p!==`object`,`The value "object" should be written as "Object"`),q.push(p)):K.push(p);if(K.length>0){let p=G.indexOf(`object`);p!==-1&&(G.slice(p,1),K.push(`Object`))}return G.length>0&&(W+=`${G.length>1?`one of type`:`of type`} ${formatList(G,`or`)}`,(K.length>0||q.length>0)&&(W+=` or `)),K.length>0&&(W+=`an instance of ${formatList(K,`or`)}`,q.length>0&&(W+=` or `)),q.length>0&&(q.length>1?W+=`one of ${formatList(q,`or`)}`:(q[0].toLowerCase()!==q[0]&&(W+=`an `),W+=`${q[0]}`)),W+=`. Received ${determineSpecificType(U)}`,W},TypeError),codes.ERR_INVALID_MODULE_SPECIFIER=createError(`ERR_INVALID_MODULE_SPECIFIER`,(p,H,U=void 0)=>`Invalid module "${p}" ${H}${U?` imported from ${U}`:``}`,TypeError),codes.ERR_INVALID_PACKAGE_CONFIG=createError(`ERR_INVALID_PACKAGE_CONFIG`,(p,H,U)=>`Invalid package config ${p}${H?` while importing ${H}`:``}${U?`. ${U}`:``}`,Error),codes.ERR_INVALID_PACKAGE_TARGET=createError(`ERR_INVALID_PACKAGE_TARGET`,(p,H,U,W=!1,G=void 0)=>{let K=typeof U==`string`&&!W&&U.length>0&&!U.startsWith(`./`);return H===`.`?(assert(W===!1),`Invalid "exports" main target ${JSON.stringify(U)} defined in the package config ${p}package.json${G?` imported from ${G}`:``}${K?`; targets must start with "./"`:``}`):`Invalid "${W?`imports`:`exports`}" target ${JSON.stringify(U)} defined for '${H}' in the package config ${p}package.json${G?` imported from ${G}`:``}${K?`; targets must start with "./"`:``}`},Error),codes.ERR_MODULE_NOT_FOUND=createError(`ERR_MODULE_NOT_FOUND`,(p,H,U=!1)=>`Cannot find ${U?`module`:`package`} '${p}' imported from ${H}`,Error),codes.ERR_NETWORK_IMPORT_DISALLOWED=createError(`ERR_NETWORK_IMPORT_DISALLOWED`,`import of '%s' by %s is not supported: %s`,Error),codes.ERR_PACKAGE_IMPORT_NOT_DEFINED=createError(`ERR_PACKAGE_IMPORT_NOT_DEFINED`,(p,H,U)=>`Package import specifier "${p}" is not defined${H?` in package ${H}package.json`:``} imported from ${U}`,TypeError),codes.ERR_PACKAGE_PATH_NOT_EXPORTED=createError(`ERR_PACKAGE_PATH_NOT_EXPORTED`,(p,H,U=void 0)=>H===`.`?`No "exports" main defined in ${p}package.json${U?` imported from ${U}`:``}`:`Package subpath '${H}' is not defined by "exports" in ${p}package.json${U?` imported from ${U}`:``}`,Error),codes.ERR_UNSUPPORTED_DIR_IMPORT=createError(`ERR_UNSUPPORTED_DIR_IMPORT`,`Directory import '%s' is not supported resolving ES modules imported from %s`,Error),codes.ERR_UNSUPPORTED_RESOLVE_REQUEST=createError(`ERR_UNSUPPORTED_RESOLVE_REQUEST`,`Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.`,TypeError),codes.ERR_UNKNOWN_FILE_EXTENSION=createError(`ERR_UNKNOWN_FILE_EXTENSION`,(p,H)=>`Unknown file extension "${p}" for ${H}`,TypeError),codes.ERR_INVALID_ARG_VALUE=createError(`ERR_INVALID_ARG_VALUE`,(p,H,U=`is invalid`)=>{let W=inspect(H);return W.length>128&&(W=`${W.slice(0,128)}...`),`The ${p.includes(`.`)?`property`:`argument`} '${p}' ${U}. Received ${W}`},TypeError);function createError(p,H,U){return messages.set(p,H),makeNodeErrorWithCode(U,p)}function makeNodeErrorWithCode(p,H){return U;function U(...U){let W=Error.stackTraceLimit;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=0);let G=new p;isErrorStackTraceLimitWritable()&&(Error.stackTraceLimit=W);let K=getMessage(H,U,G);return Object.defineProperties(G,{message:{value:K,enumerable:!1,writable:!0,configurable:!0},toString:{value(){return`${this.name} [${H}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}}),captureLargerStackTrace(G),G.code=H,G}}function isErrorStackTraceLimitWritable(){try{if(v8.startupSnapshot.isBuildingSnapshot())return!1}catch{}let p=Object.getOwnPropertyDescriptor(Error,`stackTraceLimit`);return p===void 0?Object.isExtensible(Error):own$1.call(p,`writable`)&&p.writable!==void 0?p.writable:p.set!==void 0}function hideStackFrames(p){let H=`__node_internal_`+p.name;return Object.defineProperty(p,`name`,{value:H}),p}const captureLargerStackTrace=hideStackFrames(function(p){let H=isErrorStackTraceLimitWritable();return H&&(userStackTraceLimit=Error.stackTraceLimit,Error.stackTraceLimit=1/0),Error.captureStackTrace(p),H&&(Error.stackTraceLimit=userStackTraceLimit),p});function getMessage(p,H,U){let W=messages.get(p);if(assert(W!==void 0,"expected `message` to be found"),typeof W==`function`)return assert(W.length<=H.length,`Code: ${p}; The provided arguments length (${H.length}) does not match the required ones (${W.length}).`),Reflect.apply(W,U,H);let G=/%[dfijoOs]/g,K=0;for(;G.exec(W)!==null;)K++;return assert(K===H.length,`Code: ${p}; The provided arguments length (${H.length}) does not match the required ones (${K}).`),H.length===0?W:(H.unshift(W),Reflect.apply(format,null,H))}function determineSpecificType(p){if(p==null)return String(p);if(typeof p==`function`&&p.name)return`function ${p.name}`;if(typeof p==`object`)return p.constructor&&p.constructor.name?`an instance of ${p.constructor.name}`:`${inspect(p,{depth:-1})}`;let H=inspect(p,{colors:!1});return H.length>28&&(H=`${H.slice(0,25)}...`),`type ${typeof p} (${H})`}const hasOwnProperty$1={}.hasOwnProperty,{ERR_INVALID_PACKAGE_CONFIG:ERR_INVALID_PACKAGE_CONFIG$1}=codes,cache=new Map;function read(p,{base:H,specifier:W}){let G=cache.get(p);if(G)return G;let K;try{K=fs.readFileSync(path.toNamespacedPath(p),`utf8`)}catch(p){let H=p;if(H.code!==`ENOENT`)throw H}let q={exists:!1,pjsonPath:p,main:void 0,name:void 0,type:`none`,exports:void 0,imports:void 0};if(K!==void 0){let U;try{U=JSON.parse(K)}catch(U){let G=U,K=new ERR_INVALID_PACKAGE_CONFIG$1(p,(H?`"${W}" from `:``)+fileURLToPath(H||W),G.message);throw K.cause=G,K}q.exists=!0,hasOwnProperty$1.call(U,`name`)&&typeof U.name==`string`&&(q.name=U.name),hasOwnProperty$1.call(U,`main`)&&typeof U.main==`string`&&(q.main=U.main),hasOwnProperty$1.call(U,`exports`)&&(q.exports=U.exports),hasOwnProperty$1.call(U,`imports`)&&(q.imports=U.imports),hasOwnProperty$1.call(U,`type`)&&(U.type===`commonjs`||U.type===`module`)&&(q.type=U.type)}return cache.set(p,q),q}function getPackageScopeConfig(p){let H=new URL(`package.json`,p);for(;!H.pathname.endsWith(`node_modules/package.json`);){let U=read(fileURLToPath(H),{specifier:p});if(U.exists)return U;let W=H;if(H=new URL(`../package.json`,H),H.pathname===W.pathname)break}return{pjsonPath:fileURLToPath(H),exists:!1,type:`none`}}function getPackageType(p){return getPackageScopeConfig(p).type}const{ERR_UNKNOWN_FILE_EXTENSION}=codes,hasOwnProperty={}.hasOwnProperty,extensionFormatMap={__proto__:null,".cjs":`commonjs`,".js":`module`,".json":`json`,".mjs":`module`};function mimeToFormat(p){return p&&/\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(p)?`module`:p===`application/json`?`json`:null}const protocolHandlers={__proto__:null,"data:":getDataProtocolModuleFormat,"file:":getFileProtocolModuleFormat,"http:":getHttpProtocolModuleFormat,"https:":getHttpProtocolModuleFormat,"node:"(){return`builtin`}};function getDataProtocolModuleFormat(p){let{1:H}=/^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(p.pathname)||[null,null,null];return mimeToFormat(H)}function extname$2(p){let H=p.pathname,U=H.length;for(;U--;){let p=H.codePointAt(U);if(p===47)return``;if(p===46)return H.codePointAt(U-1)===47?``:H.slice(U)}return``}function getFileProtocolModuleFormat(p,H,U){let W=extname$2(p);if(W===`.js`){let H=getPackageType(p);return H===`none`?`commonjs`:H}if(W===``){let H=getPackageType(p);return H===`none`||H===`commonjs`?`commonjs`:`module`}let G=extensionFormatMap[W];if(G)return G;if(!U)throw new ERR_UNKNOWN_FILE_EXTENSION(W,fileURLToPath(p))}function getHttpProtocolModuleFormat(){}function defaultGetFormatWithoutErrors(p,H){let U=p.protocol;return hasOwnProperty.call(protocolHandlers,U)&&protocolHandlers[U](p,H,!0)||null}const RegExpPrototypeSymbolReplace=RegExp.prototype[Symbol.replace],{ERR_INVALID_MODULE_SPECIFIER,ERR_INVALID_PACKAGE_CONFIG,ERR_INVALID_PACKAGE_TARGET,ERR_MODULE_NOT_FOUND,ERR_PACKAGE_IMPORT_NOT_DEFINED,ERR_PACKAGE_PATH_NOT_EXPORTED,ERR_UNSUPPORTED_DIR_IMPORT,ERR_UNSUPPORTED_RESOLVE_REQUEST}=codes,own={}.hasOwnProperty,invalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,deprecatedInvalidSegmentRegEx=/(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,invalidPackageNameRegEx=/^\.|%|\\/,patternRegEx=/\*/g,encodedSeparatorRegEx=/%2f|%5c/i,emittedPackageWarnings=new Set,doubleSlashRegEx=/[/\\]{2}/;function emitInvalidSegmentDeprecation(p,H,U,W,G,K,q){if(process$1.noDeprecation)return;let Y=fileURLToPath(W),X=doubleSlashRegEx.exec(q?p:H)!==null;process$1.emitWarning(`Use of deprecated ${X?`double slash`:`leading or trailing slash matching`} resolving "${p}" for module request "${H}" ${H===U?``:`matched to "${U}" `}in the "${G?`imports`:`exports`}" field module resolution of the package at ${Y}${K?` imported from ${fileURLToPath(K)}`:``}.`,`DeprecationWarning`,`DEP0166`)}function emitLegacyIndexDeprecation(p,H,U,W){if(process$1.noDeprecation||defaultGetFormatWithoutErrors(p,{parentURL:U.href})!==`module`)return;let G=fileURLToPath(p.href),K=fileURLToPath(new URL$1(`.`,H)),Y=fileURLToPath(U);W?path.resolve(K,W)!==G&&process$1.emitWarning(`Package ${K} has a "main" field set to "${W}", excluding the full filename and extension to the resolved file at "${G.slice(K.length)}", imported from ${Y}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`,`DeprecationWarning`,`DEP0151`):process$1.emitWarning(`No "main" or "exports" field defined in the package.json for ${K} resolving the main entry point "${G.slice(K.length)}", imported from ${Y}.\nDefault "index" lookups for the main are deprecated for ES modules.`,`DeprecationWarning`,`DEP0151`)}function tryStatSync(p){try{return statSync(p)}catch{}}function fileExists(p){let H=statSync(p,{throwIfNoEntry:!1});return(H?H.isFile():void 0)??!1}function legacyMainResolve(p,H,U){let W;if(H.main!==void 0){if(W=new URL$1(H.main,p),fileExists(W))return W;let G=[`./${H.main}.js`,`./${H.main}.json`,`./${H.main}.node`,`./${H.main}/index.js`,`./${H.main}/index.json`,`./${H.main}/index.node`],K=-1;for(;++K<G.length&&(W=new URL$1(G[K],p),!fileExists(W));)W=void 0;if(W)return emitLegacyIndexDeprecation(W,p,U,H.main),W}let G=[`./index.js`,`./index.json`,`./index.node`],K=-1;for(;++K<G.length&&(W=new URL$1(G[K],p),!fileExists(W));)W=void 0;if(W)return emitLegacyIndexDeprecation(W,p,U,H.main),W;throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL$1(`.`,p)),fileURLToPath(U))}function finalizeResolution(p,H,U){if(encodedSeparatorRegEx.exec(p.pathname)!==null)throw new ERR_INVALID_MODULE_SPECIFIER(p.pathname,`must not include encoded "/" or "\\" characters`,fileURLToPath(H));let W;try{W=fileURLToPath(p)}catch(U){let W=U;throw Object.defineProperty(W,`input`,{value:String(p)}),Object.defineProperty(W,`module`,{value:String(H)}),W}let K=tryStatSync(W.endsWith(`/`)?W.slice(-1):W);if(K&&K.isDirectory()){let U=new ERR_UNSUPPORTED_DIR_IMPORT(W,fileURLToPath(H));throw U.url=String(p),U}if(!K||!K.isFile()){let U=new ERR_MODULE_NOT_FOUND(W||p.pathname,H&&fileURLToPath(H),!0);throw U.url=String(p),U}{let H=realpathSync(W),{search:U,hash:K}=p;p=pathToFileURL(H+(W.endsWith(path.sep)?`/`:``)),p.search=U,p.hash=K}return p}function importNotDefined(p,H,U){return new ERR_PACKAGE_IMPORT_NOT_DEFINED(p,H&&fileURLToPath(new URL$1(`.`,H)),fileURLToPath(U))}function exportsNotFound(p,H,U){return new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL$1(`.`,H)),p,U&&fileURLToPath(U))}function throwInvalidSubpath(p,H,U,W,G){throw new ERR_INVALID_MODULE_SPECIFIER(p,`request is not a valid match in pattern "${H}" for the "${W?`imports`:`exports`}" resolution of ${fileURLToPath(U)}`,G&&fileURLToPath(G))}function invalidPackageTarget(p,H,U,W,G){return H=typeof H==`object`&&H?JSON.stringify(H,null,``):`${H}`,new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL$1(`.`,U)),p,H,W,G&&fileURLToPath(G))}function resolvePackageTargetString(p,H,U,W,G,K,J,Y,X){if(H!==``&&!K&&p[p.length-1]!==`/`)throw invalidPackageTarget(U,p,W,J,G);if(!p.startsWith(`./`)){if(J&&!p.startsWith(`../`)&&!p.startsWith(`/`)){let U=!1;try{new URL$1(p),U=!0}catch{}if(!U)return packageResolve(K?RegExpPrototypeSymbolReplace.call(patternRegEx,p,()=>H):p+H,W,X)}throw invalidPackageTarget(U,p,W,J,G)}if(invalidSegmentRegEx.exec(p.slice(2))!==null)if(deprecatedInvalidSegmentRegEx.exec(p.slice(2))===null){if(!Y){let q=K?U.replace(`*`,()=>H):U+H;emitInvalidSegmentDeprecation(K?RegExpPrototypeSymbolReplace.call(patternRegEx,p,()=>H):p,q,U,W,J,G,!0)}}else throw invalidPackageTarget(U,p,W,J,G);let Z=new URL$1(p,W),Q=Z.pathname,$=new URL$1(`.`,W).pathname;if(!Q.startsWith($))throw invalidPackageTarget(U,p,W,J,G);if(H===``)return Z;if(invalidSegmentRegEx.exec(H)!==null){let q=K?U.replace(`*`,()=>H):U+H;deprecatedInvalidSegmentRegEx.exec(H)===null?Y||emitInvalidSegmentDeprecation(K?RegExpPrototypeSymbolReplace.call(patternRegEx,p,()=>H):p,q,U,W,J,G,!1):throwInvalidSubpath(q,U,W,J,G)}return K?new URL$1(RegExpPrototypeSymbolReplace.call(patternRegEx,Z.href,()=>H)):new URL$1(H,Z)}function isArrayIndex(p){let H=Number(p);return`${H}`===p?H>=0&&H<4294967295:!1}function resolvePackageTarget(p,H,U,W,G,K,q,Y,X){if(typeof H==`string`)return resolvePackageTargetString(H,U,W,p,G,K,q,Y,X);if(Array.isArray(H)){let J=H;if(J.length===0)return null;let Z,Q=-1;for(;++Q<J.length;){let H=J[Q],$;try{$=resolvePackageTarget(p,H,U,W,G,K,q,Y,X)}catch(p){let H=p;if(Z=H,H.code===`ERR_INVALID_PACKAGE_TARGET`)continue;throw p}if($!==void 0){if($===null){Z=null;continue}return $}}if(Z==null)return null;throw Z}if(typeof H==`object`&&H){let Z=Object.getOwnPropertyNames(H),Q=-1;for(;++Q<Z.length;){let H=Z[Q];if(isArrayIndex(H))throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(p),G,`"exports" cannot contain numeric property keys.`)}for(Q=-1;++Q<Z.length;){let J=Z[Q];if(J===`default`||X&&X.has(J)){let Z=H[J],Q=resolvePackageTarget(p,Z,U,W,G,K,q,Y,X);if(Q===void 0)continue;return Q}}return null}if(H===null)return null;throw invalidPackageTarget(W,H,p,q,G)}function isConditionalExportsMainSugar(p,H,U){if(typeof p==`string`||Array.isArray(p))return!0;if(typeof p!=`object`||!p)return!1;let W=Object.getOwnPropertyNames(p),G=!1,K=0,q=-1;for(;++q<W.length;){let p=W[q],Y=p===``||p[0]!==`.`;if(K++===0)G=Y;else if(G!==Y)throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(H),U,`"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`)}return G}function emitTrailingSlashPatternDeprecation(p,H,U){if(process$1.noDeprecation)return;let W=fileURLToPath(H);emittedPackageWarnings.has(W+`|`+p)||(emittedPackageWarnings.add(W+`|`+p),process$1.emitWarning(`Use of deprecated trailing slash pattern mapping "${p}" in the "exports" field module resolution of the package at ${W}${U?` imported from ${fileURLToPath(U)}`:``}. Mapping specifiers ending in "/" is no longer supported.`,`DeprecationWarning`,`DEP0155`))}function packageExportsResolve(p,H,U,W,G){let K=U.exports;if(isConditionalExportsMainSugar(K,p,W)&&(K={".":K}),own.call(K,H)&&!H.includes(`*`)&&!H.endsWith(`/`)){let U=K[H],q=resolvePackageTarget(p,U,``,H,W,!1,!1,!1,G);if(q==null)throw exportsNotFound(H,p,W);return q}let q=``,J=``,Y=Object.getOwnPropertyNames(K),X=-1;for(;++X<Y.length;){let U=Y[X],G=U.indexOf(`*`);if(G!==-1&&H.startsWith(U.slice(0,G))){H.endsWith(`/`)&&emitTrailingSlashPatternDeprecation(H,p,W);let K=U.slice(G+1);H.length>=U.length&&H.endsWith(K)&&patternKeyCompare(q,U)===1&&U.lastIndexOf(`*`)===G&&(q=U,J=H.slice(G,H.length-K.length))}}if(q){let U=K[q],Y=resolvePackageTarget(p,U,J,q,W,!0,!1,H.endsWith(`/`),G);if(Y==null)throw exportsNotFound(H,p,W);return Y}throw exportsNotFound(H,p,W)}function patternKeyCompare(p,H){let U=p.indexOf(`*`),W=H.indexOf(`*`),G=U===-1?p.length:U+1,K=W===-1?H.length:W+1;return G>K?-1:K>G||U===-1?1:W===-1||p.length>H.length?-1:H.length>p.length?1:0}function packageImportsResolve(p,H,U){if(p===`#`||p.startsWith(`#/`)||p.endsWith(`/`))throw new ERR_INVALID_MODULE_SPECIFIER(p,`is not a valid internal imports specifier name`,fileURLToPath(H));let W,G=getPackageScopeConfig(H);if(G.exists){W=pathToFileURL(G.pjsonPath);let K=G.imports;if(K)if(own.call(K,p)&&!p.includes(`*`)){let G=resolvePackageTarget(W,K[p],``,p,H,!1,!0,!1,U);if(G!=null)return G}else{let G=``,q=``,J=Object.getOwnPropertyNames(K),Y=-1;for(;++Y<J.length;){let H=J[Y],U=H.indexOf(`*`);if(U!==-1&&p.startsWith(H.slice(0,-1))){let W=H.slice(U+1);p.length>=H.length&&p.endsWith(W)&&patternKeyCompare(G,H)===1&&H.lastIndexOf(`*`)===U&&(G=H,q=p.slice(U,p.length-W.length))}}if(G){let p=K[G],J=resolvePackageTarget(W,p,q,G,H,!0,!0,!1,U);if(J!=null)return J}}}throw importNotDefined(p,W,H)}function parsePackageName(p,H){let U=p.indexOf(`/`),W=!0,G=!1;p[0]===`@`&&(G=!0,U===-1||p.length===0?W=!1:U=p.indexOf(`/`,U+1));let K=U===-1?p:p.slice(0,U);if(invalidPackageNameRegEx.exec(K)!==null&&(W=!1),!W)throw new ERR_INVALID_MODULE_SPECIFIER(p,`is not a valid package name`,fileURLToPath(H));return{packageName:K,packageSubpath:`.`+(U===-1?``:p.slice(U)),isScoped:G}}function packageResolve(p,H,U){if(builtinModules.includes(p))return new URL$1(`node:`+p);let{packageName:W,packageSubpath:G,isScoped:K}=parsePackageName(p,H),X=getPackageScopeConfig(H);if(X.exists){let p=pathToFileURL(X.pjsonPath);if(X.name===W&&X.exports!==void 0&&X.exports!==null)return packageExportsResolve(p,G,X,H,U)}let Z=new URL$1(`./node_modules/`+W+`/package.json`,H),Q=fileURLToPath(Z),$;do{let Y=tryStatSync(Q.slice(0,-13));if(!Y||!Y.isDirectory()){$=Q,Z=new URL$1((K?`../../../../node_modules/`:`../../../node_modules/`)+W+`/package.json`,Z),Q=fileURLToPath(Z);continue}let X=read(Q,{base:H,specifier:p});return X.exports!==void 0&&X.exports!==null?packageExportsResolve(Z,G,X,H,U):G===`.`?legacyMainResolve(Z,X,H):new URL$1(G,Z)}while(Q.length!==$.length);throw new ERR_MODULE_NOT_FOUND(W,fileURLToPath(H),!1)}function isRelativeSpecifier(p){return p[0]===`.`&&(p.length===1||p[1]===`/`||p[1]===`.`&&(p.length===2||p[2]===`/`))}function shouldBeTreatedAsRelativeOrAbsolutePath(p){return p===``?!1:p[0]===`/`?!0:isRelativeSpecifier(p)}function moduleResolve(p,H,U,W){let G=H.protocol,K=G===`data:`||G===`http:`||G===`https:`,J;if(shouldBeTreatedAsRelativeOrAbsolutePath(p))try{J=new URL$1(p,H)}catch(U){let W=new ERR_UNSUPPORTED_RESOLVE_REQUEST(p,H);throw W.cause=U,W}else if(G===`file:`&&p[0]===`#`)J=packageImportsResolve(p,H,U);else try{J=new URL$1(p)}catch(W){if(K&&!builtinModules.includes(p)){let U=new ERR_UNSUPPORTED_RESOLVE_REQUEST(p,H);throw U.cause=W,U}J=packageResolve(p,H,U)}return assert(J!==void 0,`expected to be defined`),J.protocol===`file:`?finalizeResolution(J,H):J}function fileURLToPath$1(p){return typeof p==`string`&&!p.startsWith(`file://`)?normalizeSlash(p):normalizeSlash(fileURLToPath(p))}function pathToFileURL$1(p){return pathToFileURL(fileURLToPath$1(p)).toString()}function normalizeid(p){return typeof p!=`string`&&(p=p.toString()),/(?:node|data|http|https|file):/.test(p)?p:BUILTIN_MODULES.has(p)?`node:`+p:`file://`+encodeURI(normalizeSlash(p))}function isNodeBuiltin(p=``){return p=p.replace(/^node:/,``).split(`/`,1)[0],BUILTIN_MODULES.has(p)}const ProtocolRegex=/^(?<proto>.{2,}?):.+$/;function getProtocol(p){let H=p.match(ProtocolRegex);return H?H.groups?.proto:void 0}const DEFAULT_CONDITIONS_SET=new Set([`node`,`import`]),DEFAULT_EXTENSIONS=[`.mjs`,`.cjs`,`.js`,`.json`],NOT_FOUND_ERRORS=new Set([`ERR_MODULE_NOT_FOUND`,`ERR_UNSUPPORTED_DIR_IMPORT`,`MODULE_NOT_FOUND`,`ERR_PACKAGE_PATH_NOT_EXPORTED`]);function _tryModuleResolve(p,H,U){try{return moduleResolve(p,H,U)}catch(p){if(!NOT_FOUND_ERRORS.has(p?.code))throw p}}function _resolve(p,H={}){if(typeof p!=`string`)if(p instanceof URL)p=fileURLToPath$1(p);else throw TypeError("input must be a `string` or `URL`");if(/(?:node|data|http|https):/.test(p))return p;if(BUILTIN_MODULES.has(p))return`node:`+p;if(p.startsWith(`file://`)&&(p=fileURLToPath$1(p)),isAbsolute$1(p))try{if(statSync(p).isFile())return pathToFileURL$1(p)}catch(p){if(p?.code!==`ENOENT`)throw p}let U=H.conditions?new Set(H.conditions):DEFAULT_CONDITIONS_SET,W=(Array.isArray(H.url)?H.url:[H.url]).filter(Boolean).map(p=>new URL(normalizeid(p.toString())));W.length===0&&W.push(new URL(pathToFileURL$1(process.cwd())));let G=[...W];for(let p of W)p.protocol===`file:`&&G.push(new URL(`./`,p),new URL(joinURL(p.pathname,`_index.js`),p),new URL(`node_modules`,p));let q;for(let W of G){if(q=_tryModuleResolve(p,W,U),q)break;for(let G of[``,`/index`]){for(let K of H.extensions||DEFAULT_EXTENSIONS)if(q=_tryModuleResolve(joinURL(p,G)+K,W,U),q)break;if(q)break}if(q)break}if(!q){let H=Error(`Cannot find module ${p} imported from ${G.join(`, `)}`);throw H.code=`ERR_MODULE_NOT_FOUND`,H}return pathToFileURL$1(q)}function resolveSync(p,H){return _resolve(p,H)}function resolvePathSync(p,H){return fileURLToPath$1(resolveSync(p,H))}function resolvePath(p,H){try{return Promise.resolve(resolvePathSync(p,H))}catch(p){return Promise.reject(p)}}const NODE_MODULES_RE=/^(.+\/node_modules\/)([^/@]+|@[^/]+\/[^/]+)(\/?.*?)?$/;function parseNodeModulePath(p){if(!p)return{};p=normalize(fileURLToPath$1(p));let H=NODE_MODULES_RE.exec(p);if(!H)return{};let[,U,W,G]=H;return{dir:U,name:W,subpath:G?`.${G}`:void 0}}async function lookupNodeModuleSubpath(p){p=normalize(fileURLToPath$1(p));let{name:H,subpath:U}=parseNodeModulePath(p);if(!H||!U)return U;let{exports:W}=await readPackageJSON(p).catch(()=>{})||{};if(W){let p=_findSubpath(U,W);if(p)return p}return U}function _findSubpath(p,H){return typeof H==`string`&&(H={".":H}),p.startsWith(`.`)||(p=p.startsWith(`/`)?`.${p}`:`./${p}`),p in(H||{})?p:_flattenExports(H).find(H=>H.fsPath===p)?.subpath}function _flattenExports(p={},H=`./`){return Object.entries(p).flatMap(([p,U])=>{let[W,G]=p.startsWith(`.`)?[p.slice(1),void 0]:[``,p],K=joinURL(H,W);return typeof U==`string`?[{subpath:K,fsPath:U,condition:G}]:_flattenExports(U,K)})}const ESM_RE=/(?:[\s;]|^)(?:import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m,COMMENT_RE=/\/\*.+?\*\/|\/\/.*(?=[nr])/g,BUILTIN_EXTENSIONS=new Set([`.mjs`,`.cjs`,`.node`,`.wasm`]);function hasESMSyntax(p,H={}){return H.stripComments&&(p=p.replace(COMMENT_RE,``)),ESM_RE.test(p)}const validNodeImportDefaults={allowedProtocols:[`node`,`file`,`data`]};async function isValidNodeImport(p,H={}){if(isNodeBuiltin(p))return!0;let U={...validNodeImportDefaults,...H},G=getProtocol(p);if(G&&!U.allowedProtocols?.includes(G))return!1;if(G===`data`)return!0;let K=await resolvePath(p,U),q=extname$1(K);return BUILTIN_EXTENSIONS.has(q)?!0:q===`.js`?(await readPackageJSON(K).catch(()=>{}))?.type===`module`?!0:/\.(?:\w+-)?esm?(?:-\w+)?\.js$|\/esm?\//.test(K)?!1:!hasESMSyntax(U.code||await promises.readFile(K,`utf8`).catch(()=>{})||``,{stripComments:U.stripComments}):!1}export{basename as a,join as c,resolve as d,parseNodeModulePath as i,normalize as l,lookupNodeModuleSubpath as n,dirname$1 as o,normalizeid as r,isAbsolute$1 as s,isValidNodeImport as t,relative as u};