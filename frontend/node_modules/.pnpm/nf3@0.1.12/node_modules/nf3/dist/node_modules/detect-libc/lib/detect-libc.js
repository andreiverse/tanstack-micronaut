"use strict";const childProcess=require(`child_process`),{isLinux,getReport}=require(`./process`),{LDD_PATH,SELF_PATH,readFile,readFileSync}=require(`./filesystem`),{interpreterPath}=require(`./elf`);let cachedFamilyInterpreter,cachedFamilyFilesystem,cachedVersionFilesystem;const command=`getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true`;let commandOut=``;const safeCommand=()=>commandOut||new Promise(F=>{childProcess.exec(command,(m,I)=>{commandOut=m?` `:I,F(commandOut)})}),safeCommandSync=()=>{if(!commandOut)try{commandOut=childProcess.execSync(command,{encoding:`utf8`})}catch{commandOut=` `}return commandOut},GLIBC=`glibc`,RE_GLIBC_VERSION=/LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i,MUSL=`musl`,isFileMusl=m=>m.includes(`libc.musl-`)||m.includes(`ld-musl-`),familyFromReport=()=>{let m=getReport();return m.header&&m.header.glibcVersionRuntime?GLIBC:Array.isArray(m.sharedObjects)&&m.sharedObjects.some(isFileMusl)?MUSL:null},familyFromCommand=m=>{let[F,I]=m.split(/[\r\n]+/);return F&&F.includes(GLIBC)?GLIBC:I&&I.includes(MUSL)?MUSL:null},familyFromInterpreterPath=m=>{if(m){if(m.includes(`/ld-musl-`))return MUSL;if(m.includes(`/ld-linux-`))return GLIBC}return null},getFamilyFromLddContent=m=>(m=m.toString(),m.includes(`musl`)?MUSL:m.includes(`GNU C Library`)?GLIBC:null),familyFromFilesystem=async()=>{if(cachedFamilyFilesystem!==void 0)return cachedFamilyFilesystem;cachedFamilyFilesystem=null;try{cachedFamilyFilesystem=getFamilyFromLddContent(await readFile(LDD_PATH))}catch{}return cachedFamilyFilesystem},familyFromFilesystemSync=()=>{if(cachedFamilyFilesystem!==void 0)return cachedFamilyFilesystem;cachedFamilyFilesystem=null;try{cachedFamilyFilesystem=getFamilyFromLddContent(readFileSync(LDD_PATH))}catch{}return cachedFamilyFilesystem},familyFromInterpreter=async()=>{if(cachedFamilyInterpreter!==void 0)return cachedFamilyInterpreter;cachedFamilyInterpreter=null;try{cachedFamilyInterpreter=familyFromInterpreterPath(interpreterPath(await readFile(SELF_PATH)))}catch{}return cachedFamilyInterpreter},familyFromInterpreterSync=()=>{if(cachedFamilyInterpreter!==void 0)return cachedFamilyInterpreter;cachedFamilyInterpreter=null;try{cachedFamilyInterpreter=familyFromInterpreterPath(interpreterPath(readFileSync(SELF_PATH)))}catch{}return cachedFamilyInterpreter},family=async()=>{let m=null;return isLinux()&&(m=await familyFromInterpreter(),m||(m=await familyFromFilesystem(),m||=familyFromReport(),m||=familyFromCommand(await safeCommand()))),m},familySync=()=>{let m=null;return isLinux()&&(m=familyFromInterpreterSync(),m||(m=familyFromFilesystemSync(),m||=familyFromReport(),m||=familyFromCommand(safeCommandSync()))),m},isNonGlibcLinux=async()=>isLinux()&&await family()!==GLIBC,isNonGlibcLinuxSync=()=>isLinux()&&familySync()!==GLIBC,versionFromFilesystem=async()=>{if(cachedVersionFilesystem!==void 0)return cachedVersionFilesystem;cachedVersionFilesystem=null;try{let m=(await readFile(LDD_PATH)).match(RE_GLIBC_VERSION);m&&(cachedVersionFilesystem=m[1])}catch{}return cachedVersionFilesystem},versionFromFilesystemSync=()=>{if(cachedVersionFilesystem!==void 0)return cachedVersionFilesystem;cachedVersionFilesystem=null;try{let m=readFileSync(LDD_PATH).match(RE_GLIBC_VERSION);m&&(cachedVersionFilesystem=m[1])}catch{}return cachedVersionFilesystem},versionFromReport=()=>{let m=getReport();return m.header&&m.header.glibcVersionRuntime?m.header.glibcVersionRuntime:null},versionSuffix=m=>m.trim().split(/\s+/)[1],versionFromCommand=m=>{let[F,I,L]=m.split(/[\r\n]+/);return F&&F.includes(GLIBC)?versionSuffix(F):I&&L&&I.includes(MUSL)?versionSuffix(L):null},version=async()=>{let m=null;return isLinux()&&(m=await versionFromFilesystem(),m||=versionFromReport(),m||=versionFromCommand(await safeCommand())),m},versionSync=()=>{let m=null;return isLinux()&&(m=versionFromFilesystemSync(),m||=versionFromReport(),m||=versionFromCommand(safeCommandSync())),m};module.exports={GLIBC,MUSL,family,familySync,isNonGlibcLinux,isNonGlibcLinuxSync,version,versionSync};