"use strict";const SPACE_CHARACTERS=/\s+/g;class Range{constructor(g,_){if(_=parseOptions(_),g instanceof Range)return g.loose===!!_.loose&&g.includePrerelease===!!_.includePrerelease?g:new Range(g.raw,_);if(g instanceof Comparator)return this.raw=g.value,this.set=[[g]],this.formatted=void 0,this;if(this.options=_,this.loose=!!_.loose,this.includePrerelease=!!_.includePrerelease,this.raw=g.trim().replace(SPACE_CHARACTERS,` `),this.set=this.raw.split(`||`).map(e=>this.parseRange(e.trim())).filter(e=>e.length),!this.set.length)throw TypeError(`Invalid SemVer Range: ${this.raw}`);if(this.set.length>1){let e=this.set[0];if(this.set=this.set.filter(e=>!isNullSet(e[0])),this.set.length===0)this.set=[e];else if(this.set.length>1){for(let e of this.set)if(e.length===1&&isAny(e[0])){this.set=[e];break}}}this.formatted=void 0}get range(){if(this.formatted===void 0){this.formatted=``;for(let e=0;e<this.set.length;e++){e>0&&(this.formatted+=`||`);let h=this.set[e];for(let e=0;e<h.length;e++)e>0&&(this.formatted+=` `),this.formatted+=h[e].toString().trim()}}return this.formatted}format(){return this.range}toString(){return this.range}parseRange(e){let h=((this.options.includePrerelease&&FLAG_INCLUDE_PRERELEASE)|(this.options.loose&&FLAG_LOOSE))+`:`+e,g=cache.get(h);if(g)return g;let v=this.options.loose,x=v?re[t.HYPHENRANGELOOSE]:re[t.HYPHENRANGE];e=e.replace(x,hyphenReplace(this.options.includePrerelease)),debug(`hyphen replace`,e),e=e.replace(re[t.COMPARATORTRIM],comparatorTrimReplace),debug(`comparator trim`,e),e=e.replace(re[t.TILDETRIM],tildeTrimReplace),debug(`tilde trim`,e),e=e.replace(re[t.CARETTRIM],caretTrimReplace),debug(`caret trim`,e);let D=e.split(` `).map(e=>parseComparator(e,this.options)).join(` `).split(/\s+/).map(e=>replaceGTE0(e,this.options));v&&(D=D.filter(e=>(debug(`loose invalid filter`,e,this.options),!!e.match(re[t.COMPARATORLOOSE])))),debug(`range list`,D);let O=new Map,k=D.map(e=>new Comparator(e,this.options));for(let e of k){if(isNullSet(e))return[e];O.set(e.value,e)}O.size>1&&O.has(``)&&O.delete(``);let A=[...O.values()];return cache.set(h,A),A}intersects(e,g){if(!(e instanceof Range))throw TypeError(`a Range is required`);return this.set.some(h=>isSatisfiable(h,g)&&e.set.some(e=>isSatisfiable(e,g)&&h.every(h=>e.every(e=>h.intersects(e,g)))))}test(e){if(!e)return!1;if(typeof e==`string`)try{e=new SemVer(e,this.options)}catch{return!1}for(let h=0;h<this.set.length;h++)if(testSet(this.set[h],e,this.options))return!0;return!1}}module.exports=Range;const LRU=require(`../internal/lrucache`),cache=new LRU,parseOptions=require(`../internal/parse-options`),Comparator=require(`./comparator`),debug=require(`../internal/debug`),SemVer=require(`./semver`),{safeRe:re,t,comparatorTrimReplace,tildeTrimReplace,caretTrimReplace}=require(`../internal/re`),{FLAG_INCLUDE_PRERELEASE,FLAG_LOOSE}=require(`../internal/constants`),isNullSet=e=>e.value===`<0.0.0-0`,isAny=e=>e.value===``,isSatisfiable=(e,h)=>{let g=!0,_=e.slice(),v=_.pop();for(;g&&_.length;)g=_.every(e=>v.intersects(e,h)),v=_.pop();return g},parseComparator=(e,h)=>(e=e.replace(re[t.BUILD],``),debug(`comp`,e,h),e=replaceCarets(e,h),debug(`caret`,e),e=replaceTildes(e,h),debug(`tildes`,e),e=replaceXRanges(e,h),debug(`xrange`,e),e=replaceStars(e,h),debug(`stars`,e),e),isX=e=>!e||e.toLowerCase()===`x`||e===`*`,replaceTildes=(e,h)=>e.trim().split(/\s+/).map(e=>replaceTilde(e,h)).join(` `),replaceTilde=(e,h)=>{let g=h.loose?re[t.TILDELOOSE]:re[t.TILDE];return e.replace(g,(h,g,_,v,y)=>{debug(`tilde`,e,h,g,_,v,y);let x;return isX(g)?x=``:isX(_)?x=`>=${g}.0.0 <${+g+1}.0.0-0`:isX(v)?x=`>=${g}.${_}.0 <${g}.${+_+1}.0-0`:y?(debug(`replaceTilde pr`,y),x=`>=${g}.${_}.${v}-${y} <${g}.${+_+1}.0-0`):x=`>=${g}.${_}.${v} <${g}.${+_+1}.0-0`,debug(`tilde return`,x),x})},replaceCarets=(e,h)=>e.trim().split(/\s+/).map(e=>replaceCaret(e,h)).join(` `),replaceCaret=(e,h)=>{debug(`caret`,e,h);let g=h.loose?re[t.CARETLOOSE]:re[t.CARET],_=h.includePrerelease?`-0`:``;return e.replace(g,(h,g,v,y,x)=>{debug(`caret`,e,h,g,v,y,x);let S;return isX(g)?S=``:isX(v)?S=`>=${g}.0.0${_} <${+g+1}.0.0-0`:isX(y)?S=g===`0`?`>=${g}.${v}.0${_} <${g}.${+v+1}.0-0`:`>=${g}.${v}.0${_} <${+g+1}.0.0-0`:x?(debug(`replaceCaret pr`,x),S=g===`0`?v===`0`?`>=${g}.${v}.${y}-${x} <${g}.${v}.${+y+1}-0`:`>=${g}.${v}.${y}-${x} <${g}.${+v+1}.0-0`:`>=${g}.${v}.${y}-${x} <${+g+1}.0.0-0`):(debug(`no pr`),S=g===`0`?v===`0`?`>=${g}.${v}.${y}${_} <${g}.${v}.${+y+1}-0`:`>=${g}.${v}.${y}${_} <${g}.${+v+1}.0-0`:`>=${g}.${v}.${y} <${+g+1}.0.0-0`),debug(`caret return`,S),S})},replaceXRanges=(e,h)=>(debug(`replaceXRanges`,e,h),e.split(/\s+/).map(e=>replaceXRange(e,h)).join(` `)),replaceXRange=(e,h)=>{e=e.trim();let g=h.loose?re[t.XRANGELOOSE]:re[t.XRANGE];return e.replace(g,(g,_,v,y,x,S)=>{debug(`xRange`,e,g,_,v,y,x,S);let C=isX(v),w=C||isX(y),T=w||isX(x),E=T;return _===`=`&&E&&(_=``),S=h.includePrerelease?`-0`:``,C?g=_===`>`||_===`<`?`<0.0.0-0`:`*`:_&&E?(w&&(y=0),x=0,_===`>`?(_=`>=`,w?(v=+v+1,y=0,x=0):(y=+y+1,x=0)):_===`<=`&&(_=`<`,w?v=+v+1:y=+y+1),_===`<`&&(S=`-0`),g=`${_+v}.${y}.${x}${S}`):w?g=`>=${v}.0.0${S} <${+v+1}.0.0-0`:T&&(g=`>=${v}.${y}.0${S} <${v}.${+y+1}.0-0`),debug(`xRange return`,g),g})},replaceStars=(e,h)=>(debug(`replaceStars`,e,h),e.trim().replace(re[t.STAR],``)),replaceGTE0=(e,h)=>(debug(`replaceGTE0`,e,h),e.trim().replace(re[h.includePrerelease?t.GTE0PRE:t.GTE0],``)),hyphenReplace=e=>(h,g,_,v,y,b,x,S,C,w,T,E)=>(g=isX(_)?``:isX(v)?`>=${_}.0.0${e?`-0`:``}`:isX(y)?`>=${_}.${v}.0${e?`-0`:``}`:b?`>=${g}`:`>=${g}${e?`-0`:``}`,S=isX(C)?``:isX(w)?`<${+C+1}.0.0-0`:isX(T)?`<${C}.${+w+1}.0-0`:E?`<=${C}.${w}.${T}-${E}`:e?`<${C}.${w}.${+T+1}-0`:`<=${S}`,`${g} ${S}`.trim()),testSet=(e,h,g)=>{for(let g=0;g<e.length;g++)if(!e[g].test(h))return!1;if(h.prerelease.length&&!g.includePrerelease){for(let g=0;g<e.length;g++)if(debug(e[g].semver),e[g].semver!==Comparator.ANY&&e[g].semver.prerelease.length>0){let _=e[g].semver;if(_.major===h.major&&_.minor===h.minor&&_.patch===h.patch)return!0}return!1}return!0};