"use strict";module.exports=exports=install,exports.usage=`Attempts to install pre-built binary for module`;const fs=require(`fs`),path=require(`path`),log=require(`./util/log.js`),existsAsync=fs.exists||path.exists,versioning=require(`./util/versioning.js`),napi=require(`./util/napi.js`),fetch=require(`node-fetch`),tar=require(`tar`);let npgVersion=`unknown`;try{let n=fs.readFileSync(path.join(__dirname,`..`,`package.json`),`utf8`);npgVersion=JSON.parse(n).version}catch{}function place_binary(t,r,i,a){log.log(`GET`,t);let s=process.env.npm_config_user_agent||`node `+process.version,l=t.replace(`+`,`%2B`),d={uri:l,headers:{"User-Agent":`node-pre-gyp (v`+npgVersion+`, `+s+`)`},follow_max:10};if(i.cafile)try{d.ca=fs.readFileSync(i.cafile)}catch(e){return a(e)}else i.ca&&(d.ca=i.ca);let f=i.proxy||process.env.http_proxy||process.env.HTTP_PROXY||process.env.npm_config_proxy,p;if(f){let{HttpsProxyAgent:e}=require(`https-proxy-agent`);p=new e(f),log.log(`download`,`proxy agent configured using: "${f}"`)}fetch(l,{agent:p}).then(e=>{if(!e.ok)throw Error(`response status ${e.status} ${e.statusText} on ${l}`);let t=e.body;return new Promise((e,i)=>{let a=0;t.pipe(extract(r,e=>{a+=1,log.info(`install`,`unpacking ${e.path}`)})).on(`error`,e=>{i(e)}),t.on(`end`,()=>{e(`extracted file count: ${a}`)}),t.on(`error`,e=>{i(e)})})}).then(e=>{log.info(e),a()}).catch(e=>{log.error(`install ${e.message}`),a(e)})}function extract(e,t){return tar.extract({cwd:e,strip:1,onentry:t})}function extract_from_local(t,r,i){if(!fs.existsSync(t))return i(Error(`Cannot find file `+t));log.info(`Found local file to extract from `+t);let a=0;function o(e){a+=1,log.info(`install`,`unpacking `+e.path)}function s(e){if(e)return i(e);if(a===0)return i(Error(`There was a fatal problem while extracting the tarball`));log.info(`tarball`,`done parsing tarball`),i()}fs.createReadStream(t).pipe(extract(r,o)).on(`close`,s).on(`error`,s)}function do_build(e,t,n){let r=[`rebuild`].concat(t);e.todo.push({name:`build`,args:r}),process.nextTick(n)}function print_fallback_error(e,t,r){let i=` (falling back to source compile with node-gyp)`,a=``;e.statusCode===void 0?(a=`Pre-built binaries not installable for `+r.name+`@`+r.version,a+=` and `+t.runtime+`@`+(t.target||process.versions.node)+` (`+t.node_abi+` ABI, `+t.libc+`)`,a+=i,log.warn(a),log.warn(`Hit error `+e.message)):(a=`Pre-built binaries not found for `+r.name+`@`+r.version,a+=` and `+t.runtime+`@`+(t.target||process.versions.node)+` (`+t.node_abi+` ABI, `+t.libc+`)`,a+=i,log.warn(`Tried to download(`+e.statusCode+`): `+t.hosted_tarball),log.warn(a),log.error(e.message))}function install(o,s,c){let u=o.package_json,m=napi.get_napi_build_version_from_command_args(s),h=o.opts[`build-from-source`]||o.opts.build_from_source,g=o.opts[`update-binary`]||o.opts.update_binary;if(h===u.name||h===!0||h===`true`)return log.info(`build`,`requesting source compile`),do_build(o,s,c);{let a=o.opts[`fallback-to-build`]||o.opts.fallback_to_build,h=a===u.name||a===!0||a===`true`;if(process.env.npm_config_argv){let e=JSON.parse(process.env.npm_config_argv).cooked,t=e.indexOf(`--fallback-to-build`);t>-1&&e.length>t&&e[t+1]===`false`&&(h=!1,log.info(`install`,`Build fallback disabled via npm flag: --fallback-to-build=false`))}let _;try{_=versioning.evaluate(u,o.opts,m)}catch(e){return c(e)}_.ca=o.opts.ca,_.cafile=o.opts.cafile;let v=_.hosted_tarball,y=_.module_path,b=path.join(y,_.module_name+`.node`);existsAsync(b,t=>{if(!g){if(t)return console.log(`[`+u.name+`] Success: "`+b+`" already installed`),console.log(`Pass --update-binary to reinstall or --build-from-source to recompile`),c();log.info(`check`,`checked for "`+b+`" (not found)`)}fs.promises.mkdir(y,{recursive:!0}).then(()=>{let e=v.startsWith(`file://`)&&v.slice(7);e?extract_from_local(e,y,r):place_binary(v,y,_,r)}).catch(e=>{r(e)});function r(e){return e&&h?(print_fallback_error(e,_,u),do_build(o,s,c)):e?c(e):(console.log(`[`+u.name+`] Success: "`+b+`" is installed via remote`),c())}})}}