"use strict";var __importDefault=this&&this.__importDefault||function(h){return h&&h.__esModule?h:{default:h}};Object.defineProperty(exports,`__esModule`,{value:!0}),exports.WriteStreamSync=exports.WriteStream=exports.ReadStreamSync=exports.ReadStream=void 0;const events_1=__importDefault(require(`events`)),fs_1=__importDefault(require(`fs`)),minipass_1=require(`minipass`),writev=fs_1.default.writev,_autoClose=Symbol(`_autoClose`),_close=Symbol(`_close`),_ended=Symbol(`_ended`),_fd=Symbol(`_fd`),_finished=Symbol(`_finished`),_flags=Symbol(`_flags`),_flush=Symbol(`_flush`),_handleChunk=Symbol(`_handleChunk`),_makeBuf=Symbol(`_makeBuf`),_mode=Symbol(`_mode`),_needDrain=Symbol(`_needDrain`),_onerror=Symbol(`_onerror`),_onopen=Symbol(`_onopen`),_onread=Symbol(`_onread`),_onwrite=Symbol(`_onwrite`),_open=Symbol(`_open`),_path=Symbol(`_path`),_pos=Symbol(`_pos`),_queue=Symbol(`_queue`),_read=Symbol(`_read`),_readSize=Symbol(`_readSize`),_reading=Symbol(`_reading`),_remain=Symbol(`_remain`),_size=Symbol(`_size`),_write=Symbol(`_write`),_writing=Symbol(`_writing`),_defaultFlag=Symbol(`_defaultFlag`),_errored=Symbol(`_errored`);class ReadStream extends minipass_1.Minipass{[_errored]=!1;[_fd];[_path];[_readSize];[_reading]=!1;[_size];[_remain];[_autoClose];constructor(h,F){if(F||={},super(F),this.readable=!0,this.writable=!1,typeof h!=`string`)throw TypeError(`path must be a string`);this[_errored]=!1,this[_fd]=typeof F.fd==`number`?F.fd:void 0,this[_path]=h,this[_readSize]=F.readSize||16*1024*1024,this[_reading]=!1,this[_size]=typeof F.size==`number`?F.size:1/0,this[_remain]=this[_size],this[_autoClose]=typeof F.autoClose==`boolean`?F.autoClose:!0,typeof this[_fd]==`number`?this[_read]():this[_open]()}get fd(){return this[_fd]}get path(){return this[_path]}write(){throw TypeError(`this is a readable stream`)}end(){throw TypeError(`this is a readable stream`)}[_open](){fs_1.default.open(this[_path],`r`,(h,F)=>this[_onopen](h,F))}[_onopen](h,F){h?this[_onerror](h):(this[_fd]=F,this.emit(`open`,F),this[_read]())}[_makeBuf](){return Buffer.allocUnsafe(Math.min(this[_readSize],this[_remain]))}[_read](){if(!this[_reading]){this[_reading]=!0;let h=this[_makeBuf]();if(h.length===0)return process.nextTick(()=>this[_onread](null,0,h));fs_1.default.read(this[_fd],h,0,h.length,null,(h,F,I)=>this[_onread](h,F,I))}}[_onread](h,F,I){this[_reading]=!1,h?this[_onerror](h):this[_handleChunk](F,I)&&this[_read]()}[_close](){if(this[_autoClose]&&typeof this[_fd]==`number`){let h=this[_fd];this[_fd]=void 0,fs_1.default.close(h,h=>h?this.emit(`error`,h):this.emit(`close`))}}[_onerror](h){this[_reading]=!0,this[_close](),this.emit(`error`,h)}[_handleChunk](h,F){let I=!1;return this[_remain]-=h,h>0&&(I=super.write(h<F.length?F.subarray(0,h):F)),(h===0||this[_remain]<=0)&&(I=!1,this[_close](),super.end()),I}emit(h,...F){switch(h){case`prefinish`:case`finish`:return!1;case`drain`:return typeof this[_fd]==`number`&&this[_read](),!1;case`error`:return this[_errored]?!1:(this[_errored]=!0,super.emit(h,...F));default:return super.emit(h,...F)}}}exports.ReadStream=ReadStream;class ReadStreamSync extends ReadStream{[_open](){let h=!0;try{this[_onopen](null,fs_1.default.openSync(this[_path],`r`)),h=!1}finally{h&&this[_close]()}}[_read](){let h=!0;try{if(!this[_reading]){this[_reading]=!0;do{let h=this[_makeBuf](),F=h.length===0?0:fs_1.default.readSync(this[_fd],h,0,h.length,null);if(!this[_handleChunk](F,h))break}while(!0);this[_reading]=!1}h=!1}finally{h&&this[_close]()}}[_close](){if(this[_autoClose]&&typeof this[_fd]==`number`){let h=this[_fd];this[_fd]=void 0,fs_1.default.closeSync(h),this.emit(`close`)}}}exports.ReadStreamSync=ReadStreamSync;class WriteStream extends events_1.default{readable=!1;writable=!0;[_errored]=!1;[_writing]=!1;[_ended]=!1;[_queue]=[];[_needDrain]=!1;[_path];[_mode];[_autoClose];[_fd];[_defaultFlag];[_flags];[_finished]=!1;[_pos];constructor(h,F){F||={},super(F),this[_path]=h,this[_fd]=typeof F.fd==`number`?F.fd:void 0,this[_mode]=F.mode===void 0?438:F.mode,this[_pos]=typeof F.start==`number`?F.start:void 0,this[_autoClose]=typeof F.autoClose==`boolean`?F.autoClose:!0;let I=this[_pos]===void 0?`w`:`r+`;this[_defaultFlag]=F.flags===void 0,this[_flags]=F.flags===void 0?I:F.flags,this[_fd]===void 0&&this[_open]()}emit(h,...F){if(h===`error`){if(this[_errored])return!1;this[_errored]=!0}return super.emit(h,...F)}get fd(){return this[_fd]}get path(){return this[_path]}[_onerror](h){this[_close](),this[_writing]=!0,this.emit(`error`,h)}[_open](){fs_1.default.open(this[_path],this[_flags],this[_mode],(h,F)=>this[_onopen](h,F))}[_onopen](h,F){this[_defaultFlag]&&this[_flags]===`r+`&&h&&h.code===`ENOENT`?(this[_flags]=`w`,this[_open]()):h?this[_onerror](h):(this[_fd]=F,this.emit(`open`,F),this[_writing]||this[_flush]())}end(h,F){return h&&this.write(h,F),this[_ended]=!0,!this[_writing]&&!this[_queue].length&&typeof this[_fd]==`number`&&this[_onwrite](null,0),this}write(h,F){return typeof h==`string`&&(h=Buffer.from(h,F)),this[_ended]?(this.emit(`error`,Error(`write() after end()`)),!1):this[_fd]===void 0||this[_writing]||this[_queue].length?(this[_queue].push(h),this[_needDrain]=!0,!1):(this[_writing]=!0,this[_write](h),!0)}[_write](h){fs_1.default.write(this[_fd],h,0,h.length,this[_pos],(h,F)=>this[_onwrite](h,F))}[_onwrite](h,F){h?this[_onerror](h):(this[_pos]!==void 0&&typeof F==`number`&&(this[_pos]+=F),this[_queue].length?this[_flush]():(this[_writing]=!1,this[_ended]&&!this[_finished]?(this[_finished]=!0,this[_close](),this.emit(`finish`)):this[_needDrain]&&(this[_needDrain]=!1,this.emit(`drain`))))}[_flush](){if(this[_queue].length===0)this[_ended]&&this[_onwrite](null,0);else if(this[_queue].length===1)this[_write](this[_queue].pop());else{let h=this[_queue];this[_queue]=[],writev(this[_fd],h,this[_pos],(h,F)=>this[_onwrite](h,F))}}[_close](){if(this[_autoClose]&&typeof this[_fd]==`number`){let h=this[_fd];this[_fd]=void 0,fs_1.default.close(h,h=>h?this.emit(`error`,h):this.emit(`close`))}}}exports.WriteStream=WriteStream;class WriteStreamSync extends WriteStream{[_open](){let h;if(this[_defaultFlag]&&this[_flags]===`r+`)try{h=fs_1.default.openSync(this[_path],this[_flags],this[_mode])}catch(h){if(h?.code===`ENOENT`)return this[_flags]=`w`,this[_open]();throw h}else h=fs_1.default.openSync(this[_path],this[_flags],this[_mode]);this[_onopen](null,h)}[_close](){if(this[_autoClose]&&typeof this[_fd]==`number`){let h=this[_fd];this[_fd]=void 0,fs_1.default.closeSync(h),this.emit(`close`)}}[_write](h){let F=!0;try{this[_onwrite](null,fs_1.default.writeSync(this[_fd],h,0,h.length,this[_pos])),F=!1}finally{if(F)try{this[_close]()}catch{}}}}exports.WriteStreamSync=WriteStreamSync;