"use strict";var __importDefault=this&&this.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(exports,`__esModule`,{value:!0}),exports.Minipass=exports.isWritable=exports.isReadable=exports.isStream=void 0;const proc=typeof process==`object`&&process?process:{stdout:null,stderr:null},node_events_1=require(`node:events`),node_stream_1=__importDefault(require(`node:stream`)),node_string_decoder_1=require(`node:string_decoder`),isStream=_=>!!_&&typeof _==`object`&&(_ instanceof Minipass||_ instanceof node_stream_1.default||(0,exports.isReadable)(_)||(0,exports.isWritable)(_));exports.isStream=isStream;const isReadable=_=>!!_&&typeof _==`object`&&_ instanceof node_events_1.EventEmitter&&typeof _.pipe==`function`&&_.pipe!==node_stream_1.default.Writable.prototype.pipe;exports.isReadable=isReadable;const isWritable=_=>!!_&&typeof _==`object`&&_ instanceof node_events_1.EventEmitter&&typeof _.write==`function`&&typeof _.end==`function`;exports.isWritable=isWritable;const EOF=Symbol(`EOF`),MAYBE_EMIT_END=Symbol(`maybeEmitEnd`),EMITTED_END=Symbol(`emittedEnd`),EMITTING_END=Symbol(`emittingEnd`),EMITTED_ERROR=Symbol(`emittedError`),CLOSED=Symbol(`closed`),READ=Symbol(`read`),FLUSH=Symbol(`flush`),FLUSHCHUNK=Symbol(`flushChunk`),ENCODING=Symbol(`encoding`),DECODER=Symbol(`decoder`),FLOWING=Symbol(`flowing`),PAUSED=Symbol(`paused`),RESUME=Symbol(`resume`),BUFFER=Symbol(`buffer`),PIPES=Symbol(`pipes`),BUFFERLENGTH=Symbol(`bufferLength`),BUFFERPUSH=Symbol(`bufferPush`),BUFFERSHIFT=Symbol(`bufferShift`),OBJECTMODE=Symbol(`objectMode`),DESTROYED=Symbol(`destroyed`),ERROR=Symbol(`error`),EMITDATA=Symbol(`emitData`),EMITEND=Symbol(`emitEnd`),EMITEND2=Symbol(`emitEnd2`),ASYNC=Symbol(`async`),ABORT=Symbol(`abort`),ABORTED=Symbol(`aborted`),SIGNAL=Symbol(`signal`),DATALISTENERS=Symbol(`dataListeners`),DISCARDED=Symbol(`discarded`),defer=_=>Promise.resolve().then(_),nodefer=_=>_(),isEndish=_=>_===`end`||_===`finish`||_===`prefinish`,isArrayBufferLike=_=>_ instanceof ArrayBuffer||!!_&&typeof _==`object`&&_.constructor&&_.constructor.name===`ArrayBuffer`&&_.byteLength>=0,isArrayBufferView=_=>!Buffer.isBuffer(_)&&ArrayBuffer.isView(_);class Pipe{src;dest;opts;ondrain;constructor(_,V,H){this.src=_,this.dest=V,this.opts=H,this.ondrain=()=>_[RESUME](),this.dest.on(`drain`,this.ondrain)}unpipe(){this.dest.removeListener(`drain`,this.ondrain)}proxyErrors(_){}end(){this.unpipe(),this.opts.end&&this.dest.end()}}class PipeProxyErrors extends Pipe{unpipe(){this.src.removeListener(`error`,this.proxyErrors),super.unpipe()}constructor(_,V,H){super(_,V,H),this.proxyErrors=_=>V.emit(`error`,_),_.on(`error`,this.proxyErrors)}}const isObjectModeOptions=_=>!!_.objectMode,isEncodingOptions=_=>!_.objectMode&&!!_.encoding&&_.encoding!==`buffer`;class Minipass extends node_events_1.EventEmitter{[FLOWING]=!1;[PAUSED]=!1;[PIPES]=[];[BUFFER]=[];[OBJECTMODE];[ENCODING];[ASYNC];[DECODER];[EOF]=!1;[EMITTED_END]=!1;[EMITTING_END]=!1;[CLOSED]=!1;[EMITTED_ERROR]=null;[BUFFERLENGTH]=0;[DESTROYED]=!1;[SIGNAL];[ABORTED]=!1;[DATALISTENERS]=0;[DISCARDED]=!1;writable=!0;readable=!0;constructor(..._){let V=_[0]||{};if(super(),V.objectMode&&typeof V.encoding==`string`)throw TypeError(`Encoding and objectMode may not be used together`);isObjectModeOptions(V)?(this[OBJECTMODE]=!0,this[ENCODING]=null):isEncodingOptions(V)?(this[ENCODING]=V.encoding,this[OBJECTMODE]=!1):(this[OBJECTMODE]=!1,this[ENCODING]=null),this[ASYNC]=!!V.async,this[DECODER]=this[ENCODING]?new node_string_decoder_1.StringDecoder(this[ENCODING]):null,V&&V.debugExposeBuffer===!0&&Object.defineProperty(this,`buffer`,{get:()=>this[BUFFER]}),V&&V.debugExposePipes===!0&&Object.defineProperty(this,`pipes`,{get:()=>this[PIPES]});let{signal:H}=V;H&&(this[SIGNAL]=H,H.aborted?this[ABORT]():H.addEventListener(`abort`,()=>this[ABORT]()))}get bufferLength(){return this[BUFFERLENGTH]}get encoding(){return this[ENCODING]}set encoding(_){throw Error(`Encoding must be set at instantiation time`)}setEncoding(_){throw Error(`Encoding must be set at instantiation time`)}get objectMode(){return this[OBJECTMODE]}set objectMode(_){throw Error(`objectMode must be set at instantiation time`)}get async(){return this[ASYNC]}set async(_){this[ASYNC]=this[ASYNC]||!!_}[ABORT](){this[ABORTED]=!0,this.emit(`abort`,this[SIGNAL]?.reason),this.destroy(this[SIGNAL]?.reason)}get aborted(){return this[ABORTED]}set aborted(_){}write(_,V,H){if(this[ABORTED])return!1;if(this[EOF])throw Error(`write after end`);if(this[DESTROYED])return this.emit(`error`,Object.assign(Error(`Cannot call write after a stream was destroyed`),{code:`ERR_STREAM_DESTROYED`})),!0;typeof V==`function`&&(H=V,V=`utf8`),V||=`utf8`;let U=this[ASYNC]?defer:nodefer;if(!this[OBJECTMODE]&&!Buffer.isBuffer(_)){if(isArrayBufferView(_))_=Buffer.from(_.buffer,_.byteOffset,_.byteLength);else if(isArrayBufferLike(_))_=Buffer.from(_);else if(typeof _!=`string`)throw Error(`Non-contiguous data written to non-objectMode stream`)}return this[OBJECTMODE]?(this[FLOWING]&&this[BUFFERLENGTH]!==0&&this[FLUSH](!0),this[FLOWING]?this.emit(`data`,_):this[BUFFERPUSH](_),this[BUFFERLENGTH]!==0&&this.emit(`readable`),H&&U(H),this[FLOWING]):_.length?(typeof _==`string`&&!(V===this[ENCODING]&&!this[DECODER]?.lastNeed)&&(_=Buffer.from(_,V)),Buffer.isBuffer(_)&&this[ENCODING]&&(_=this[DECODER].write(_)),this[FLOWING]&&this[BUFFERLENGTH]!==0&&this[FLUSH](!0),this[FLOWING]?this.emit(`data`,_):this[BUFFERPUSH](_),this[BUFFERLENGTH]!==0&&this.emit(`readable`),H&&U(H),this[FLOWING]):(this[BUFFERLENGTH]!==0&&this.emit(`readable`),H&&U(H),this[FLOWING])}read(_){if(this[DESTROYED])return null;if(this[DISCARDED]=!1,this[BUFFERLENGTH]===0||_===0||_&&_>this[BUFFERLENGTH])return this[MAYBE_EMIT_END](),null;this[OBJECTMODE]&&(_=null),this[BUFFER].length>1&&!this[OBJECTMODE]&&(this[BUFFER]=[this[ENCODING]?this[BUFFER].join(``):Buffer.concat(this[BUFFER],this[BUFFERLENGTH])]);let V=this[READ](_||null,this[BUFFER][0]);return this[MAYBE_EMIT_END](),V}[READ](_,V){if(this[OBJECTMODE])this[BUFFERSHIFT]();else{let H=V;_===H.length||_===null?this[BUFFERSHIFT]():typeof H==`string`?(this[BUFFER][0]=H.slice(_),V=H.slice(0,_),this[BUFFERLENGTH]-=_):(this[BUFFER][0]=H.subarray(_),V=H.subarray(0,_),this[BUFFERLENGTH]-=_)}return this.emit(`data`,V),!this[BUFFER].length&&!this[EOF]&&this.emit(`drain`),V}end(_,V,H){return typeof _==`function`&&(H=_,_=void 0),typeof V==`function`&&(H=V,V=`utf8`),_!==void 0&&this.write(_,V),H&&this.once(`end`,H),this[EOF]=!0,this.writable=!1,(this[FLOWING]||!this[PAUSED])&&this[MAYBE_EMIT_END](),this}[RESUME](){this[DESTROYED]||(!this[DATALISTENERS]&&!this[PIPES].length&&(this[DISCARDED]=!0),this[PAUSED]=!1,this[FLOWING]=!0,this.emit(`resume`),this[BUFFER].length?this[FLUSH]():this[EOF]?this[MAYBE_EMIT_END]():this.emit(`drain`))}resume(){return this[RESUME]()}pause(){this[FLOWING]=!1,this[PAUSED]=!0,this[DISCARDED]=!1}get destroyed(){return this[DESTROYED]}get flowing(){return this[FLOWING]}get paused(){return this[PAUSED]}[BUFFERPUSH](_){this[OBJECTMODE]?this[BUFFERLENGTH]+=1:this[BUFFERLENGTH]+=_.length,this[BUFFER].push(_)}[BUFFERSHIFT](){return this[OBJECTMODE]?--this[BUFFERLENGTH]:this[BUFFERLENGTH]-=this[BUFFER][0].length,this[BUFFER].shift()}[FLUSH](_=!1){do;while(this[FLUSHCHUNK](this[BUFFERSHIFT]())&&this[BUFFER].length);!_&&!this[BUFFER].length&&!this[EOF]&&this.emit(`drain`)}[FLUSHCHUNK](_){return this.emit(`data`,_),this[FLOWING]}pipe(_,H){if(this[DESTROYED])return _;this[DISCARDED]=!1;let U=this[EMITTED_END];return H||={},_===proc.stdout||_===proc.stderr?H.end=!1:H.end=H.end!==!1,H.proxyErrors=!!H.proxyErrors,U?H.end&&_.end():(this[PIPES].push(H.proxyErrors?new PipeProxyErrors(this,_,H):new Pipe(this,_,H)),this[ASYNC]?defer(()=>this[RESUME]()):this[RESUME]()),_}unpipe(_){let V=this[PIPES].find(V=>V.dest===_);V&&(this[PIPES].length===1?(this[FLOWING]&&this[DATALISTENERS]===0&&(this[FLOWING]=!1),this[PIPES]=[]):this[PIPES].splice(this[PIPES].indexOf(V),1),V.unpipe())}addListener(_,V){return this.on(_,V)}on(_,V){let H=super.on(_,V);if(_===`data`)this[DISCARDED]=!1,this[DATALISTENERS]++,!this[PIPES].length&&!this[FLOWING]&&this[RESUME]();else if(_===`readable`&&this[BUFFERLENGTH]!==0)super.emit(`readable`);else if(isEndish(_)&&this[EMITTED_END])super.emit(_),this.removeAllListeners(_);else if(_===`error`&&this[EMITTED_ERROR]){let _=V;this[ASYNC]?defer(()=>_.call(this,this[EMITTED_ERROR])):_.call(this,this[EMITTED_ERROR])}return H}removeListener(_,V){return this.off(_,V)}off(_,V){let H=super.off(_,V);return _===`data`&&(this[DATALISTENERS]=this.listeners(`data`).length,this[DATALISTENERS]===0&&!this[DISCARDED]&&!this[PIPES].length&&(this[FLOWING]=!1)),H}removeAllListeners(_){let V=super.removeAllListeners(_);return(_===`data`||_===void 0)&&(this[DATALISTENERS]=0,!this[DISCARDED]&&!this[PIPES].length&&(this[FLOWING]=!1)),V}get emittedEnd(){return this[EMITTED_END]}[MAYBE_EMIT_END](){!this[EMITTING_END]&&!this[EMITTED_END]&&!this[DESTROYED]&&this[BUFFER].length===0&&this[EOF]&&(this[EMITTING_END]=!0,this.emit(`end`),this.emit(`prefinish`),this.emit(`finish`),this[CLOSED]&&this.emit(`close`),this[EMITTING_END]=!1)}emit(_,...V){let H=V[0];if(_!==`error`&&_!==`close`&&_!==DESTROYED&&this[DESTROYED])return!1;if(_===`data`)return!this[OBJECTMODE]&&!H?!1:this[ASYNC]?(defer(()=>this[EMITDATA](H)),!0):this[EMITDATA](H);if(_===`end`)return this[EMITEND]();if(_===`close`){if(this[CLOSED]=!0,!this[EMITTED_END]&&!this[DESTROYED])return!1;let _=super.emit(`close`);return this.removeAllListeners(`close`),_}else if(_===`error`){this[EMITTED_ERROR]=H,super.emit(ERROR,H);let _=!this[SIGNAL]||this.listeners(`error`).length?super.emit(`error`,H):!1;return this[MAYBE_EMIT_END](),_}else if(_===`resume`){let _=super.emit(`resume`);return this[MAYBE_EMIT_END](),_}else if(_===`finish`||_===`prefinish`){let V=super.emit(_);return this.removeAllListeners(_),V}let U=super.emit(_,...V);return this[MAYBE_EMIT_END](),U}[EMITDATA](_){for(let V of this[PIPES])V.dest.write(_)===!1&&this.pause();let V=this[DISCARDED]?!1:super.emit(`data`,_);return this[MAYBE_EMIT_END](),V}[EMITEND](){return this[EMITTED_END]?!1:(this[EMITTED_END]=!0,this.readable=!1,this[ASYNC]?(defer(()=>this[EMITEND2]()),!0):this[EMITEND2]())}[EMITEND2](){if(this[DECODER]){let _=this[DECODER].end();if(_){for(let V of this[PIPES])V.dest.write(_);this[DISCARDED]||super.emit(`data`,_)}}for(let _ of this[PIPES])_.end();let _=super.emit(`end`);return this.removeAllListeners(`end`),_}async collect(){let _=Object.assign([],{dataLength:0});this[OBJECTMODE]||(_.dataLength=0);let V=this.promise();return this.on(`data`,V=>{_.push(V),this[OBJECTMODE]||(_.dataLength+=V.length)}),await V,_}async concat(){if(this[OBJECTMODE])throw Error(`cannot concat in objectMode`);let _=await this.collect();return this[ENCODING]?_.join(``):Buffer.concat(_,_.dataLength)}async promise(){return new Promise((_,V)=>{this.on(DESTROYED,()=>V(Error(`stream destroyed`))),this.on(`error`,_=>V(_)),this.on(`end`,()=>_())})}[Symbol.asyncIterator](){this[DISCARDED]=!1;let _=!1,V=async()=>(this.pause(),_=!0,{value:void 0,done:!0});return{next:()=>{if(_)return V();let H=this.read();if(H!==null)return Promise.resolve({done:!1,value:H});if(this[EOF])return V();let U,W,G=_=>{this.off(`data`,K),this.off(`end`,q),this.off(DESTROYED,J),V(),W(_)},K=_=>{this.off(`error`,G),this.off(`end`,q),this.off(DESTROYED,J),this.pause(),U({value:_,done:!!this[EOF]})},q=()=>{this.off(`error`,G),this.off(`data`,K),this.off(DESTROYED,J),V(),U({done:!0,value:void 0})},J=()=>G(Error(`stream destroyed`));return new Promise((_,V)=>{W=V,U=_,this.once(DESTROYED,J),this.once(`error`,G),this.once(`end`,q),this.once(`data`,K)})},throw:V,return:V,[Symbol.asyncIterator](){return this}}}[Symbol.iterator](){this[DISCARDED]=!1;let _=!1,V=()=>(this.pause(),this.off(ERROR,V),this.off(DESTROYED,V),this.off(`end`,V),_=!0,{done:!0,value:void 0});return this.once(`end`,V),this.once(ERROR,V),this.once(DESTROYED,V),{next:()=>{if(_)return V();let H=this.read();return H===null?V():{done:!1,value:H}},throw:V,return:V,[Symbol.iterator](){return this}}}destroy(_){if(this[DESTROYED])return _?this.emit(`error`,_):this.emit(DESTROYED),this;this[DESTROYED]=!0,this[DISCARDED]=!0,this[BUFFER].length=0,this[BUFFERLENGTH]=0;let V=this;return typeof V.close==`function`&&!this[CLOSED]&&V.close(),_?this.emit(`error`,_):this.emit(DESTROYED),this}static get isStream(){return exports.isStream}}exports.Minipass=Minipass;