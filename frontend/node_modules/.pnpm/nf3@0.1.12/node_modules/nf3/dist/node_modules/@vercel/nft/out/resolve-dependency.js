"use strict";Object.defineProperty(exports,`__esModule`,{value:!0}),exports.NotFoundError=void 0,exports.default=resolveDependency;const path_1=require(`path`),module_1=require(`module`),node_version_1=require(`./utils/node-version`);async function resolveDependency(r,i,a,s=!0){let c;if((0,path_1.isAbsolute)(r)||r===`.`||r===`..`||r.startsWith(`./`)||r.startsWith(`../`)){let s=r.endsWith(`/`);c=await resolvePath((0,path_1.resolve)(i,`..`,r)+(s?`/`:``),i,a)}else c=r[0]===`#`?await packageImportsResolve(r,i,a,s):await resolvePackage(r,i,a,s);return Array.isArray(c)?Promise.all(c.map(e=>a.realpath(e,i))):c.startsWith(`node:`)?c:a.realpath(c,i)}async function resolvePath(e,r,i){let a=await resolveFile(e,r,i)||await resolveDir(e,r,i);if(!a)throw new NotFoundError(e,r);return a}async function resolveFile(r,i,a){if(!r.endsWith(`/`)){if(r=await a.realpath(r,i),await a.isFile(r))return r;if(a.ts&&r.startsWith(a.base)&&r.slice(a.base.length).indexOf(path_1.sep+`node_modules`+path_1.sep)===-1&&await a.isFile(r+`.ts`))return r+`.ts`;if(a.ts&&r.startsWith(a.base)&&r.slice(a.base.length).indexOf(path_1.sep+`node_modules`+path_1.sep)===-1&&await a.isFile(r+`.tsx`))return r+`.tsx`;if(await a.isFile(r+`.js`))return r+`.js`;if(await a.isFile(r+`.json`))return r+`.json`;if(await a.isFile(r+`.node`))return r+`.node`}}async function resolveDir(r,i,a){if(r.endsWith(`/`)&&(r=r.slice(0,-1)),!await a.isDir(r))return;let o=await getPkgCfg(r,a);if(o&&typeof o.main==`string`){let c=await resolveFile((0,path_1.resolve)(r,o.main),i,a)||await resolveFile((0,path_1.resolve)(r,o.main,`index`),i,a);if(c)return await a.emitFile(r+path_1.sep+`package.json`,`resolve`,i),c}return resolveFile((0,path_1.resolve)(r,`index`),i,a)}class NotFoundError extends Error{code;constructor(e,r){super(`Cannot find module '`+e+`' loaded from `+r),this.code=`MODULE_NOT_FOUND`}}exports.NotFoundError=NotFoundError;const nodeBuiltins=new Set(module_1.builtinModules);function getPkgName(e){let r=e.split(`/`);return e[0]===`@`&&r.length>1?r.length>1?r.slice(0,2).join(`/`):null:r.length?r[0]:null}async function getPkgCfg(r,i){let a=await i.readFile(r+path_1.sep+`package.json`);if(a)try{return JSON.parse(a.toString())}catch{}}function getExportsTarget(e,r,a){if(typeof e==`string`||e===null)return e;if(Array.isArray(e))for(let i of e){let e=getExportsTarget(i,r,a);if(e===null||typeof e==`string`&&e.startsWith(`./`))return e}else if(typeof e==`object`){for(let o of Object.keys(e))if(o===`default`||o===`require`&&a||o===`import`&&!a||o===`module-sync`&&(0,node_version_1.getNodeMajorVersion)()>=22||r.includes(o)){let i=getExportsTarget(e[o],r,a);if(i!==void 0)return i}}}function resolveExportsImports(e,r,i,a,o,s){let c;if(o){if(!(typeof r==`object`&&!Array.isArray(r)&&r!==null))return;c=r}else c=typeof r==`string`||Array.isArray(r)||r===null||typeof r==`object`&&Object.keys(r).length&&Object.keys(r)[0][0]!==`.`?{".":r}:r;if(i in c){let r=getExportsTarget(c[i],a.conditions,s);if(typeof r==`string`&&r.startsWith(`./`))return e+r.slice(1)}for(let r of Object.keys(c).sort((e,r)=>r.length-e.length)){if(r.endsWith(`*`)&&i.startsWith(r.slice(0,-1))){let o=getExportsTarget(c[r],a.conditions,s);if(typeof o==`string`&&o.startsWith(`./`))return e+o.slice(1).replace(/\*/g,i.slice(r.length-1))}if(r.endsWith(`/`)&&i.startsWith(r)){let o=getExportsTarget(c[r],a.conditions,s);if(typeof o==`string`&&o.endsWith(`/`)&&o.startsWith(`./`))return e+o.slice(1)+i.slice(r.length)}}}async function resolveRemappings(r,i,a,o){if(o.conditions?.includes(`browser`)){let{browser:c}=i;if(!c)return;if(typeof c==`object`)for(let[i,l]of Object.entries(c)){if(typeof l!=`string`||!i.startsWith(`./`)||!l.startsWith(`./`))continue;let c=await resolveFile(r+path_1.sep+i,a,o),u=await resolveFile(r+path_1.sep+l,a,o);c&&u&&o.addRemapping(c,u)}}}async function packageImportsResolve(r,i,a,o){if(r!==`#`&&!r.startsWith(`#/`)&&a.conditions){let u=await a.getPjsonBoundary(i);if(u){let d=await getPkgCfg(u,a),{imports:p}=d||{};if(d&&p!=null){let d=resolveExportsImports(u,p,r,a,!0,o);if(d){if(o)d=await resolveFile(d,i,a)||await resolveDir(d,i,a);else if(!await a.isFile(d))throw new NotFoundError(d,i);if(d)return await a.emitFile(u+path_1.sep+`package.json`,`resolve`,i),d}}}}throw new NotFoundError(r,i)}async function resolvePackage(r,i,a,o){let p=i;if(nodeBuiltins.has(r))return`node:`+r;if(r.startsWith(`node:`))return r;let m=getPkgName(r)||``,h;if(a.conditions){let u=await a.getPjsonBoundary(i);if(u){let d=await getPkgCfg(u,a),{exports:p}=d||{};if(d&&d.name&&d.name===m&&p!=null){if(h=resolveExportsImports(u,p,`.`+r.slice(m.length),a,!1,o),h){if(o)h=await resolveFile(h,i,a)||await resolveDir(h,i,a);else if(!await a.isFile(h))throw new NotFoundError(h,i)}h&&await a.emitFile(u+path_1.sep+`package.json`,`resolve`,i)}}}let g,_=p.indexOf(path_1.sep);for(;(g=p.lastIndexOf(path_1.sep))>_;){p=p.slice(0,g);let u=p+path_1.sep+`node_modules`,d=await a.stat(u);if(!d||!d.isDirectory())continue;let _=await getPkgCfg(u+path_1.sep+m,a),{exports:v}=_||{};if(_&&await resolveRemappings(u+path_1.sep+m,_,i,a),a.conditions&&v!=null&&!h){let d;a.exportsOnly||(d=await resolveFile(u+path_1.sep+r,i,a)||await resolveDir(u+path_1.sep+r,i,a));let f=resolveExportsImports(u+path_1.sep+m,v,`.`+r.slice(m.length),a,!1,o);if(f){if(o)f=await resolveFile(f,i,a)||await resolveDir(f,i,a);else if(!await a.isFile(f))throw new NotFoundError(f,i)}if(f)return await a.emitFile(u+path_1.sep+m+path_1.sep+`package.json`,`resolve`,i),d&&d!==f?[f,d]:f;if(d)return d}else{let o=await resolveFile(u+path_1.sep+r,i,a)||await resolveDir(u+path_1.sep+r,i,a);if(o)return h&&h!==o?[o,h]:o}}if(h)return h;if(Object.hasOwnProperty.call(a.paths,r))return a.paths[r];for(let e of Object.keys(a.paths))if(e.endsWith(`/`)&&r.startsWith(e)){let o=a.paths[e]+r.slice(e.length),u=await resolveFile(o,i,a)||await resolveDir(o,i,a);if(!u)throw new NotFoundError(r,i);return u}throw new NotFoundError(r,i)}